VERSION 300  * LAR version 000 *

**********
* EMFE rules file created by DOC1/ADF
* Date: 09/08/1998.    Time: 16:23
* Program version: 3.0p323         
*
* DO NOT EDIT THIS FILE
*
* Initial rule     : 996
* Termination rule : 998
* Default rule     : 000
*
* Data Key "BEGINDOC  "(0)
* Data Key "PARNAM    "(1)
* Data Key "PARTOT    "(2)
* Data Key "PARCFO    "(3)
* Data Key "PARCFOEVEO"(4)
* Data Key "PARUSG    "(5)
* Data Key "PARUSGEVEO"(6)
* Data Key "SUBPAY    "(7)
* Data Key "SUBNAM    "(8)
* Data Key "SUBTOT    "(9)
* Data Key "SUBCFO    "(10)
* Data Key "SUBCFOEVEO"(11)
* Data Key "SUBUSG    "(12)
* Data Key "SUBUSGEVEO"(13)
* Data Key "ENDDOC    "(14)
* Data Key "PARPAY    "(15)
* Data Key "PARPMT    "(16)
* Data Key "PARPMTEVEO"(17)
* Data Key "SUBDIS    "(18)
* Data Key "SUBADJ    "(19)
* Data Key "PARREV    "(20)
* Data Key "PARREVEVEO"(21)
* Data Key "PARDIS    "(22)
* Data Key "PARDISEVEO"(23)
* Data Key "PARSET    "(24)
* Data Key "PARSETEVEO"(25)
* Data Key "PARADJ    "(26)
* Data Key "PARADJEVEO"(27)
* Data Key "PARWRO    "(28)
* Data Key "PARWROEVEO"(29)
* Data Key "SUBDISEVEO"(30)
* Data Key "SUBSET    "(31)
* Data Key "SUBSETEVEO"(32)
* Data Key "SUBADJEVEO"(33)
* Data Key "SUBWRO    "(34)
* Data Key "SUBWROEVEO"(35)
* Data Key "ENDSECONE "(36)
* Data Key "ENDSECTWO "(37)
* Data Key "ENDSECTHRE"(38)
*
* The CE Font Metrics Table must include
*  X0HE10R0          X0EF80            X0HE09R0         
*************

*****************
* Initialisation Rule
*   must be the same as in CFG file
******************
OUTPUT 996 055 *
STOR 19825 000  *  Set override justification to none. *
STON 19815 000  *  Initialise Highlight Colour to 0 *
STON 19819 000  *  Initialise IEL generated flag. *
STON 19818 000  *  Initialise begin document flag *
ENAM 0001  *  Enable Journal Buffering. *
REGE 0001 0989 0000  *  Set REGE Event id to 1 *
STON 1000 003 * Library PORTALJ first section *
STON 1002 001 * Library PORTAL first section *
STON 1001 002 * Library PORTALJ first keyed section *
STON 1003 000 * Library PORTAL first keyed section *
OUTF 0999 0014 =DVN  1.3 INCH *
OUTF 0999 0030 =SLPS 008.500 011.000 USLetter *
OUTF 0999 059 =DFL  X0HE10R0          X0EF80            X0HE09R0          *
OUTF 0999 025 =COMM L no-overlay-in-lar *
OUTF 0999 023 =COMM L no-image-in-lar *
STON 19839 001  *  Set the initial subpage infinite loop detect flag *
STON 0993 0001  *  Initialise environment variables *
STON 19807 0001 *
STON 19820 0000  *  Initialise environment variables *
STON 0994 0000 *
STON 19808 0000  *  Set DocId to enable Job Journal *
STOD 19810 09/08/1998  *  Rules generation date (dd/mm/yy) *
STOS 19811 008 16:23:11  *  Rules generation time (hh:mm:ss) *
COPY 19812 0056  *  EMFE run-time date (dd-mmm-yy) *
COPY 19813 0057  *  EMFE run-time time (hh:mm:ss) *
STON 19814 000  *  Set initial orientation to zero  *
CALL 994  *  Init iteration registers *
*  Init subpage registers
STOR 01007 0000  *  Initialise retainer to null string *
STOR 01008 0000  *  Initialise retainer to null string *
STOR 01009 0000  *  Initialise retainer to null string *
STOR 01010 0000  *  Initialise retainer to null string *
STOR 01011 0000  *  Initialise retainer to null string *
STOR 01012 0000  *  Initialise retainer to null string *
STOR 01013 0000  *  Initialise retainer to null string *
STOR 01017 0000  *  Initialise retainer to null string *
STOR 01018 0000  *  Initialise retainer to null string *
STOR 01019 0000  *  Initialise retainer to null string *
STOR 01020 0000  *  Initialise retainer to null string *
STOR 01021 0000  *  Initialise retainer to null string *
STOR 01022 0000  *  Initialise retainer to null string *
STOR 01023 0000  *  Initialise retainer to null string *
STOR 01024 0000  *  Initialise retainer to null string *
STOR 01025 0000  *  Initialise retainer to null string *
STOR 01026 0000  *  Initialise retainer to null string *
STOR 01036 0000  *  Initialise retainer to null string *
STOR 01037 0000  *  Initialise retainer to null string *
STOR 01038 0000  *  Initialise retainer to null string *
STOR 01045 0000  *  Initialise retainer to null string *
STOR 01046 0000  *  Initialise retainer to null string *
STOR 01047 0000  *  Initialise retainer to null string *
STOR 01049 0000  *  Initialise retainer to null string *
STOR 01062 0000  *  Initialise retainer to null string *
STOR 01063 0000  *  Initialise retainer to null string *
STOR 01068 0000  *  Initialise retainer to null string *
STOR 01071 0000  *  Initialise retainer to null string *

*************
* Termination Rule
*   must be same as in CFG File
*************
OUTPUT 998 003 *
CALL 993  *  Journal rule for last doc *
STON 19808 -1  *  Set DocId to disable Job Journal *
CALL 993  *  Journal rule for end of job *

**********
* Default Rule
*   must be same as in CFG File
***********
OUTPUT 000 002 *
OUTF 0998 0121 LAD8700A Unrecognized record key '%Ls000 300' encountered in datastream; rules aborted. Check record order in input file. *
QUIT    *  Abort *

**********
* Exception Handler Rule
***********
OUTPUT 991 000  *  Dummy Exception Handler Rule *

*********
* Register Event Rule
*   called when CE execute automatic new page command
**********
OUTPUT 989 004 *
CALL 997  *  Execute the page journal rule *
INCR 0993  *  Increment the no of pages *
INCR 19820  *  Increment the real no of pages *
STON 19819 000  *  Reset IEL flag. *

*********
* Journal Rule
*   called when begin document occurs
**********
OUTPUT 993 001 *
JUMP 0000  * A 'NOP' indicating end of all Journals; no more data documents to check for *

*********
* Journal Page Rule
*   called when begin document occurs
**********
OUTPUT 997 001 *
JUMP 0000  * A 'NOP' indicating end of all Journals; no more data documents to check for *

********
* Rule to clear all offsets after a Start new page
********
OUTPUT 995 023 *
STON 01006 0000 *
STON 01016 0000 *
STON 01028 0000 *
STON 01030 0000 *
STON 01033 0000 *
STON 01035 0000 *
STON 01041 0000 *
STON 01044 0000 *
STON 01052 0000 *
STON 01054 0000 *
STON 01056 0000 *
STON 01059 0000 *
STON 01061 0000 *
STON 01065 0000 *
STON 01067 0000 *
STON 01070 0000 *
STON 01075 0000 *
STON 01079 0000 *
STON 01081 0000 *
STON 01084 0000 *
STON 01087 0000 *
STON 01089 0000 *
STON 01093 0000 *

*******
* Rule to reset all iterations
* after Change Page Layout in an Abort Subpage
* or from the Initialisation rule
********
OUTPUT 994 009 *
STON 01005 0000 *
STON 01015 0000 *
STON 01032 0000 *
STON 01043 0000 *
STON 01058 0000 *
STON 01074 0000 *
STON 01078 0000 *
STON 01086 0000 *
STON 01092 0000 *

**********
* Begin Document output rule for Tag 'BEGINDOC  ': 
*************
OUTPUT 057 033 *
JNZ  0032 19818  *  Jump if begin document reg is non zero *
JZ   0006 0055  *  Jump if bounding box count is zero *
STOR 19981 0125 LAD8702A Inconsistency error with document number '%Ld000 994////' starting with key '%Lz000 19804.'.  Processing is aborted.  *  Format message *
OUTC 0998 19981  *  Output message to standard out *
LOGG 19981  *  Output message to log file *
TRCE 19981  *  Output message to trace file *
OUTF 0999 0006 =ZCBB   *  Zero count of bounding boxes *
QUIT  *  Abort because of error *
*  Journal Support
CALL 993  *  Journal rule *
STON 19808 0001  *  Store current tag id in journal reg *
STON 0993 0001  *  Initialise Curr No of pages *
STON 19820 0000  *  Initialise Real Curr No of pages *
INCR 0994  *  Increment the total no of docs *
STON 19831 0000  *  Set the current document layout *
STON 19829 0000  *  Clear last X position register *
STON 19828 0000  *  Clear last Y position register *
STON 19827 0000  *  Reset X direction offset *
STON 19826 0000  *  Reset Y direction offset *
STON 19817 0000  *  Reset record number *
STON 1039 0000 *
STON 1050 0000 *
STON 1072 0000 *
STON 1082 0000 *
STON 1090 0000 *
STOR 19804 0010 BEGINDOC    *  Store current tag string into register *
STOR 19822 0000   *  Store current tag label into register *
STOR 19821 0001 1  *  Store current tag id into register *
OUTF 0999 0005 =BDOC  *  Indicates start of new document *
BDOC  *  Indicates start of new document *
JEQI 0002 19814 0000  *  If the orientation has not changed, do nothing *
OUTF 0999 0009 =RPP  000  *  Change the orientation this document *
STON 19814 0000  *  Save the new orientation *
OUTF 0999 0059 =COMM ADF NEW DOC %Lz000 19804. (%Lz000 19822.) (000000000)  *  Send comment indicating current document *

**********
* OUTPUT rule for Tag 'BEGINDOC  ': 
*************
OUTPUT 056 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 055  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'SUBUSG    ': 
*************

OUTPUT 054 000 *

**********
* OUTPUT rule for Tag 'SUBUSGEVEO': 
*************

OUTPUT 053 000 *

**********
* OUTPUT rule for Tag 'ENDDOC    ': 
*************
OUTPUT 052 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 051  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'PARREV    ': 
*************

OUTPUT 050 000 *

**********
* OUTPUT rule for Tag 'PARREVEVEO': 
*************

OUTPUT 049 000 *

**********
* OUTPUT rule for Tag 'PARDISEVEO': 
*************

OUTPUT 048 000 *

**********
* OUTPUT rule for Tag 'PARSETEVEO': 
*************

OUTPUT 047 000 *

**********
* OUTPUT rule for Tag 'PARADJEVEO': 
*************

OUTPUT 046 000 *

**********
* OUTPUT rule for Tag 'PARWRO    ': 
*************

OUTPUT 045 000 *

**********
* OUTPUT rule for Tag 'PARWROEVEO': 
*************

OUTPUT 044 000 *

**********
* OUTPUT rule for Tag 'SUBDISEVEO': 
*************

OUTPUT 043 000 *

**********
* OUTPUT rule for Tag 'PARDIS    ': 
*************

OUTPUT 042 000 *

**********
* OUTPUT rule for Tag 'PARSET    ': 
*************

OUTPUT 041 000 *

**********
* OUTPUT rule for Tag 'PARPMTEVEO': 
*************

OUTPUT 040 000 *

**********
* OUTPUT rule for Tag 'PARPMT    ': 
*************

OUTPUT 039 000 *

**********
* OUTPUT rule for Tag 'PARUSGEVEO': 
*************
OUTPUT 038 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 037  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'SUBSET    ': 
*************

OUTPUT 036 000 *

**********
* OUTPUT rule for Tag 'SUBADJ    ': 
*************

OUTPUT 035 000 *

**********
* OUTPUT rule for Tag 'SUBCFOEVEO': 
*************
OUTPUT 034 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 033  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'SUBDIS    ': 
*************
OUTPUT 032 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 031  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'SUBCFO    ': 
*************
OUTPUT 030 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 029  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'SUBTOT    ': 
*************
OUTPUT 028 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 027  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'SUBNAM    ': 
*************
OUTPUT 026 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 025  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'SUBPAY    ': 
*************

OUTPUT 024 000 *

**********
* OUTPUT rule for Tag 'PARUSG    ': 
*************
OUTPUT 023 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 022  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'PARCFOEVEO': 
*************
OUTPUT 021 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 020  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'PARADJ    ': 
*************

OUTPUT 019 000 *

**********
* OUTPUT rule for Tag 'PARTOT    ': 
*************
OUTPUT 018 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 017  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'PARCFO    ': 
*************
OUTPUT 016 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 015  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'PARNAM    ': 
*************
OUTPUT 014 007 *
*
*********
* Compare the Page Layout Segment
* by setting the work register
* with the comparison value
* and conditionally skipping
* ( ie. a CASE statement )
**********
*
STON 19833 0000  *  Store PLS in Work Reg 2 *
NEQ  19832 19831 19833  *  Compare PLS reg with Reg 2 *
SKIP 19832 0002  *  Skip the call if not equal *
CALL 013  *  Call output rules for PLS *
JUMP 000  *  End of page processing *
JUMP 000  *  Acts as a final NOP command *
INCR 19817  *  Increment record number. *

**********
* OUTPUT rule for Tag 'PARPAY    ': 
*************

OUTPUT 012 000 *

**********
* OUTPUT rule for Tag 'SUBSETEVEO': 
*************

OUTPUT 011 000 *

**********
* OUTPUT rule for Tag 'SUBADJEVEO': 
*************

OUTPUT 010 000 *

**********
* OUTPUT rule for Tag 'SUBWRO    ': 
*************

OUTPUT 009 000 *

**********
* OUTPUT rule for Tag 'SUBWROEVEO': 
*************

OUTPUT 008 000 *

**********
* OUTPUT rule for Tag 'ENDSECONE ': 
*************

OUTPUT 007 000 *

**********
* OUTPUT rule for Tag 'ENDSECTWO ': 
*************

OUTPUT 006 000 *

**********
* OUTPUT rule for Tag 'ENDSECTHRE': 
*************

OUTPUT 005 000 *
*
********
* Now we know that the output rules call these rules
* which are kept as subroutines.
* All these subroutines will now be defined.
**********
*

*******
* Output command bin No: 500 for 'BEGINDOC  '
*******
OUTPUT 055 001  *  Output command bin *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 501 for 'ENDDOC    '
*******
OUTPUT 051 062  *  Output command bin *
COPY 0100 15001   * Copy field into work register <<100E>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14011 0100   * Copy to transfer register value of Symbolic Link Address <<100X>> *
OUTF 0999 0023 =SCPP  001.200  001.600   * Use absX Use absY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
COPY 0100 1071   * Get contents of retainer 'Trigger on' <<100E>> *
STOR 0101 0002 ON  *
EQ   0102 0100 0101   * if = ON *
COPY 1095 0102   * Save result of the condition 'if = ON' <<102X>> *
JZ   0048 1095   * Jump if condition 'if = ON' is not true. *
CALL 0997   * Journal page rule. *
OUTF 0999 0005 =SNP    * New logical page. *
STON 19819 0000   * Reset IEL flag. *
CALL 0995  *
STON 1006 000.000   * New iteration Y offset. *
STON 1016 000.000   * New iteration Y offset. *
STON 1028 000.000   * New iteration Y offset. *
STON 1030 000.000   * New iteration Y offset. *
STON 1033 000.000   * New iteration Y offset. *
STON 1035 000.000   * New iteration Y offset. *
STON 1041 000.000   * New iteration Y offset. *
STON 1044 000.000   * New iteration Y offset. *
STON 1052 000.000   * New iteration Y offset. *
STON 1054 000.000   * New iteration Y offset. *
STON 1056 000.000   * New iteration Y offset. *
STON 1059 000.000   * New iteration Y offset. *
STON 1061 000.000   * New iteration Y offset. *
STON 1065 000.000   * New iteration Y offset. *
STON 1067 000.000   * New iteration Y offset. *
STON 1070 000.000   * New iteration Y offset. *
STON 1075 000.000   * New iteration Y offset. *
STON 1079 000.000   * New iteration Y offset. *
STON 1081 000.000   * New iteration Y offset. *
STON 1084 000.000   * New iteration Y offset. *
STON 1087 000.000   * New iteration Y offset. *
STON 1089 000.000   * New iteration Y offset. *
STON 1093 000.000   * New iteration Y offset. *
INCR 0993   * Increment the no of pages *
INCR 19820   * Increment the real no of pages *
INCR 19807   * Increment the total no of pages. *
STOR 0100 0009     Page   *
CHRS 0101 0002 00 01   * Copy the environment <<101E>> *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 0100   * Right justified, String *
COPY 0100 0101   * Concatenate the references <<100E 101X>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14012 0100   * Copy to transfer register value of Symbolic Link Page Number <<100X>> *
COPY 0100 1013   * Get contents of retainer 'account number a' <<100E>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Concatenate the references <<100E 101X>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14011 0100   * Copy to transfer register value of Symbolic Link Account number <<100X>> *
OUTF 0999 0023 =SCPP  005.000  000.200   * Use absX Use absY  *
OUTF 0999 0005 =BTDC *
CLSD 1002 000   * Call appropriate member of the firm data library *
OUTF 0999 0005 =ETDC *
OUTF 0999 0023 =SCPP  000.800  002.200   * Use absX Use absY  *
CLSD 1002 013   * Call appropriate member of the firm data library *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 502 for 'PARUSGEVEO'
*******
OUTPUT 037 187  *  Output command bin *
SKIP 1074 0021   * Skip if not first time *
STON 1074 0001   * First time, so set absolute position *
COPY 0136 19828   * Before ite save Y offset reg value <<136E>> *
COPY 0137 19826   * Before ite save Y direction offset <<137E>> *
COPY 0138 19829   * Before ite save X offset reg value <<138E>> *
COPY 0139 19827   * Before ite save X direction offset <<139E>> *
SKIP 1072 0005   * If an anchor value was set, skip over initialisation *
SKIP 19828 0002   * Skip if there is a previous Y offset value *
STON 1056 002.200   * Init South Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1056 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.000   * Store direction offset South *
STON 19828 1056   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0135   * Restore X direction offset to appropriate context *
SKIP 19828 0002   * Skip if active Y offset *
STON 1075 000.000   * Init Iteration Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1075 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.000   * Direction offset South iteration *
STON 19828 1075   * Set Y offset reg to last used *
JUMP 0001  * Jump over direction offset clear during 1st ite *
STON 19826 000.000   * Clear direction offset for South iteration control *
JNZ  0002 1073   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01073   * Iteration print region. *
STON 1073 0001   * Set flag :  calc box has already started *
COPY 0140 15002   * Copy field into work register <<140E>> *
TRIM 0140 0140 0002   * Trim the spaces <<140E>> *
COPY 0141 0140   * Left justified, String *
COPY 0140 0141   * Copy back result of formatting <<140E 141X>> *
STOR 0141 0016 PIN_FLD_RATE_TAG  *
EQ   0141 0141 0140   * <<141E 140X>> *
JZ   0003 0141   * Jump if condition '' is not true. *
COPY 0141 15001   * Copy field into work register <<141E>> *
COPY 1045 0141   * Store Retainer value for 'description'. *
JUMP 0037  * Jump to end of the case statement *
STOR 0141 0014 PIN_FLD_AMOUNT  *
EQ   0141 0141 0140   * <<141E 140X>> *
JZ   0003 0141   * Jump if condition '' is not true. *
COPY 0141 15001   * Copy field into work register <<141E>> *
COPY 1046 0141   * Store Retainer value for 'amount'. *
JUMP 0031  * Jump to end of the case statement *
STOR 0141 0013 PIN_FLD_END_T  *
EQ   0141 0141 0140   * <<141E 140X>> *
JZ   0026 0141   * Jump if condition '' is not true. *
COPY 0141 15001   * Copy field into work register <<141E>> *
SUBS 0141 016 003 0141   * Substring <<141E>> *
COPY 1021 0141   * Store Retainer value for 'Month'. *
COPY 0141 15001   * Copy field into work register <<141E>> *
SUBS 0141 020 002 0141   * Substring <<141E>> *
COPY 1022 0141   * Store Retainer value for 'Day'. *
COPY 0141 15001   * Copy field into work register <<141E>> *
SUBS 0141 032 004 0141   * Substring <<141E>> *
COPY 1023 0141   * Store Retainer value for 'Year'. *
COPY 0141 1021   * Get contents of retainer 'Month' <<141E>> *
STOR 0141 0015 @@N%Ls000 141@@  *
MAPP 0141 0141  *
COPY 1024 0141   * Store Retainer value for 'date'. *
COPY 0141 1021   * Get contents of retainer 'Month' <<141E>> *
STOR 0142 0001    *
ADD  0141 0141 0142   * Concatenate the two strings. <<141E 142X>> *
COPY 0142 1022   * Get contents of retainer 'Day' <<142E>> *
ADD  0141 0141 0142   * Concatenate the two strings. <<141E 142X>> *
STOR 0142 0001    *
ADD  0141 0141 0142   * Concatenate the two strings. <<141E 142X>> *
COPY 0142 1023   * Get contents of retainer 'Year' <<142E>> *
ADD  0141 0141 0142   * Concatenate the two strings. <<141E 142X>> *
COPY 0142 0141   * Copy default string to result register <<142E 141X>> *
COPY 0141 0142   * Concatenate the references <<141E 142X>> *
COPY 1047 0141   * Store Retainer value for 'date and year'. *
JUMP 0002  * Jump to end of the case statement *
STON 0140 0001   * <<140E>> *
JUMP 0000  * Final NOP for case statement *
COPY 0140 15002   * Copy field into work register <<140E>> *
TRIM 0140 0140 0002   * Trim the spaces <<140E>> *
COPY 0141 0140   * Left justified, String *
COPY 0140 0141   * Copy back result of formatting <<140E 141X>> *
STOR 0141 0014 PIN_FLD_AMOUNT  *
EQ   0142 0140 0141  *
COPY 1076 0142   * Save result of the condition '' <<142X>> *
JZ   0022 1076   * Jump if condition '' is not true. *
COPY 0140 1045   * Get contents of retainer 'description' <<140E>> *
COPY 0141 0140   * Copy default string to result register <<141E 140X>> *
COPY 0140 0141   * Save the result of the formatting <<140E 141X>> *
COPY 14014 0140   * Copy to transfer register value of Symbolic Link Description <<140X>> *
COPY 0140 1046   * Get contents of retainer 'amount' <<140E>> *
COPY 0141 0140   * Copy default string to result register <<141E 140X>> *
COPY 0140 0141   * Save the result of the formatting <<140E 141X>> *
COPY 14013 0140   * Copy to transfer register value of Symbolic Link AMOUNT <<140X>> *
COPY 0140 1047   * Get contents of retainer 'date and year' <<140E>> *
COPY 0141 0140   * Copy default string to result register <<141E 140X>> *
COPY 0140 0141   * Save the result of the formatting <<140E 141X>> *
COPY 14012 0140   * Copy to transfer register value of Symbolic Link item no <<140X>> *
COPY 0140 1049   * Get contents of retainer 'account number' <<140E>> *
COPY 0141 0140   * Copy default string to result register <<141E 140X>> *
COPY 0140 0141   * Save the result of the formatting <<140E 141X>> *
COPY 14011 0140   * Copy to transfer register value of Symbolic Link Account <<140X>> *
STON 0140 -00.047   * Use RelY minus Direction Offset <<140E>> *
ICOP 0144 19828   * Copy indirectly the value of the last Y offset <<144E>> *
ADD  0144 0144 19826   * Add direction offset <<144E>> *
ADD  0143 0140 0144   * Add it to current Y offset <<143E 140X 144X>> *
OUTF 0999 0032 =SCPP  000.800  %Rg007.30143////   * Use absX ( no rel ) Use relY  *
CLSD 1002 011   * Call appropriate member of the firm data library *
SKIP 1074 0001   * Check to see if the iteration has been started. *
JUMP 0004  * If iteration not started, do not terminate it. *
OUTF 0999 0011 =ECBB 01073   * End calc of print region of iteration size (eg a single 'it') *
STON 1073 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( but use default ) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1075 0039   * Save the current Y offset *
STON 19828 1075   * Set Y offset reg to last used *
STON 0140 038   * Since iterating 'while tag is same', set up proper condition with our tag id *
NEQ  0142 0140 0045   * against the tag of the next input record *
SKIP 0142 0001   * Skip if we are at end of current it. *
RETN  * Not the end of iter, so return. *
STON 0140 038   * Store the id of the iteration tag <<140E>> *
NEQ  0141 0140 0045   * Compare id of tag of next input record is this iteration tag <<141E 140X>> *
SKIP 0141 0001   * Skip if this is the last iteration *
RETN  * Return if this is not the last iteration *
STON 1074 0000   * Reset marker so next time iteration is encountered, we know it is the 'first' time. *
STOR 0140 0003 OFF  *
COPY 1071 0140   * Store Retainer value for 'Trigger on'. *
CALL 0997   * Journal page rule. *
OUTF 0999 0005 =SNP    * New logical page. *
STON 19819 0000   * Reset IEL flag. *
CALL 0995  *
STON 1006 000.000   * New iteration Y offset. *
STON 1016 000.000   * New iteration Y offset. *
STON 1028 000.000   * New iteration Y offset. *
STON 1030 000.000   * New iteration Y offset. *
STON 1033 000.000   * New iteration Y offset. *
STON 1035 000.000   * New iteration Y offset. *
STON 1041 000.000   * New iteration Y offset. *
STON 1044 000.000   * New iteration Y offset. *
STON 1052 000.000   * New iteration Y offset. *
STON 1054 000.000   * New iteration Y offset. *
STON 1056 000.000   * New iteration Y offset. *
STON 1059 000.000   * New iteration Y offset. *
STON 1061 000.000   * New iteration Y offset. *
STON 1065 000.000   * New iteration Y offset. *
STON 1067 000.000   * New iteration Y offset. *
STON 1070 000.000   * New iteration Y offset. *
STON 1075 000.000   * New iteration Y offset. *
INCR 0993   * Increment the no of pages *
INCR 19820   * Increment the real no of pages *
INCR 19807   * Increment the total no of pages. *
COPY 19829 0138   * After ite restore offset X reg value *
COPY 19827 0139   * After ite restore X direction offset  *
COPY 19828 0136   * After ite restore offset Y reg value *
COPY 19826 0137   * After ite restore Y direction offset  *
JUMP 0000  * Acts as a ENDIF to the end of iteration code *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0134   * Restore Y direction offset to appropriate context *
COPY 19829 0132   * After mc2 restore offset X reg value *
COPY 19827 0133   * After mc2 restore X direction offset  *
COPY 19828 0130   * After mc2 restore offset Y reg value *
COPY 19826 0131   * After mc2 restore Y direction offset  *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0128   * Restore Y direction offset to appropriate context *
COPY 19829 0126   * After mc2 restore offset X reg value *
COPY 19827 0127   * After mc2 restore X direction offset  *
COPY 19828 0124   * After mc2 restore offset Y reg value *
COPY 19826 0125   * After mc2 restore Y direction offset  *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0122   * Restore Y direction offset to appropriate context *
COPY 19829 0120   * After mc2 restore offset X reg value *
COPY 19827 0121   * After mc2 restore X direction offset  *
COPY 19828 0118   * After mc2 restore offset Y reg value *
COPY 19826 0119   * After mc2 restore Y direction offset  *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0116   * Restore Y direction offset to appropriate context *
COPY 19829 0114   * After mc2 restore offset X reg value *
COPY 19827 0115   * After mc2 restore X direction offset  *
COPY 19828 0112   * After mc2 restore offset Y reg value *
COPY 19826 0113   * After mc2 restore Y direction offset  *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0110   * Restore Y direction offset to appropriate context *
COPY 19829 0108   * After mc2 restore offset X reg value *
COPY 19827 0109   * After mc2 restore X direction offset  *
COPY 19828 0106   * After mc2 restore offset Y reg value *
COPY 19826 0107   * After mc2 restore Y direction offset  *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0104   * Restore Y direction offset to appropriate context *
COPY 19829 0102   * After mc2 restore offset X reg value *
COPY 19827 0103   * After mc2 restore X direction offset  *
STON 19828 0000   * Reset last Y offset register since relativity has ended *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 503 for 'SUBCFOEVEO'
*******
OUTPUT 033 183  *  Output command bin *
SKIP 1092 0021   * Skip if not first time *
STON 1092 0001   * First time, so set absolute position *
COPY 0112 19828   * Before ite save Y offset reg value <<112E>> *
COPY 0113 19826   * Before ite save Y direction offset <<113E>> *
COPY 0114 19829   * Before ite save X offset reg value <<114E>> *
COPY 0115 19827   * Before ite save X direction offset <<115E>> *
SKIP 1090 0005   * If an anchor value was set, skip over initialisation *
SKIP 19828 0002   * Skip if there is a previous Y offset value *
STON 1084 002.200   * Init South Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1084 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.000   * Store direction offset South *
STON 19828 1084   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0111   * Restore X direction offset to appropriate context *
SKIP 19828 0002   * Skip if active Y offset *
STON 1093 000.000   * Init Iteration Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1093 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.000   * Direction offset South iteration *
STON 19828 1093   * Set Y offset reg to last used *
JUMP 0001  * Jump over direction offset clear during 1st ite *
STON 19826 000.000   * Clear direction offset for South iteration control *
JNZ  0002 1091   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01091   * Iteration print region. *
STON 1091 0001   * Set flag :  calc box has already started *
COPY 0116 15002   * Copy field into work register <<116E>> *
STOR 0117 0016 PIN_FLD_RATE_TAG  *
EQ   0117 0117 0116   * <<117E 116X>> *
JZ   0003 0117   * Jump if condition '' is not true. *
COPY 0117 15001   * Copy field into work register <<117E>> *
COPY 1045 0117   * Store Retainer value for 'description'. *
JUMP 0041  * Jump to end of the case statement *
STOR 0117 0014 PIN_FLD_AMOUNT  *
EQ   0117 0117 0116   * <<117E 116X>> *
JZ   0007 0117   * Jump if condition '' is not true. *
COPY 0117 15001   * Copy field into work register <<117E>> *
ATOF 0118 0117   * Convert string to a number. <<118E 117X>> *
COPY 0117 0118   * Copy converted result back to register <<117E 118X>> *
STOR 0118 0021 %Lg000020117$ /$ -///   * Left justified, Number (no thou sep) *
COPY 0117 0118   * Copy back result of formatting <<117E 118X>> *
COPY 1046 0117   * Store Retainer value for 'amount'. *
JUMP 0031  * Jump to end of the case statement *
STOR 0117 0013 PIN_FLD_END_T  *
EQ   0117 0117 0116   * <<117E 116X>> *
JZ   0026 0117   * Jump if condition '' is not true. *
COPY 0117 15001   * Copy field into work register <<117E>> *
SUBS 0117 016 003 0117   * Substring <<117E>> *
COPY 1021 0117   * Store Retainer value for 'Month'. *
COPY 0117 15001   * Copy field into work register <<117E>> *
SUBS 0117 020 002 0117   * Substring <<117E>> *
COPY 1022 0117   * Store Retainer value for 'Day'. *
COPY 0117 15001   * Copy field into work register <<117E>> *
SUBS 0117 032 004 0117   * Substring <<117E>> *
COPY 1023 0117   * Store Retainer value for 'Year'. *
COPY 0117 1021   * Get contents of retainer 'Month' <<117E>> *
STOR 0117 0015 @@N%Ls000 117@@  *
MAPP 0117 0117  *
COPY 1024 0117   * Store Retainer value for 'date'. *
COPY 0117 1021   * Get contents of retainer 'Month' <<117E>> *
STOR 0118 0001    *
ADD  0117 0117 0118   * Concatenate the two strings. <<117E 118X>> *
COPY 0118 1022   * Get contents of retainer 'Day' <<118E>> *
ADD  0117 0117 0118   * Concatenate the two strings. <<117E 118X>> *
STOR 0118 0001    *
ADD  0117 0117 0118   * Concatenate the two strings. <<117E 118X>> *
COPY 0118 1023   * Get contents of retainer 'Year' <<118E>> *
ADD  0117 0117 0118   * Concatenate the two strings. <<117E 118X>> *
COPY 0118 0117   * Copy default string to result register <<118E 117X>> *
COPY 0117 0118   * Concatenate the references <<117E 118X>> *
COPY 1047 0117   * Store Retainer value for 'date and year'. *
JUMP 0002  * Jump to end of the case statement *
STON 0116 0001   * <<116E>> *
JUMP 0000  * Final NOP for case statement *
COPY 0116 15002   * Copy field into work register <<116E>> *
STOR 0117 0014 PIN_FLD_AMOUNT  *
EQ   0118 0116 0117  *
COPY 1094 0118   * Save result of the condition '' <<118X>> *
JZ   0022 1094   * Jump if condition '' is not true. *
COPY 0116 1045   * Get contents of retainer 'description' <<116E>> *
COPY 0117 0116   * Copy default string to result register <<117E 116X>> *
COPY 0116 0117   * Save the result of the formatting <<116E 117X>> *
COPY 14014 0116   * Copy to transfer register value of Symbolic Link Description <<116X>> *
COPY 0116 1046   * Get contents of retainer 'amount' <<116E>> *
COPY 0117 0116   * Copy default string to result register <<117E 116X>> *
COPY 0116 0117   * Save the result of the formatting <<116E 117X>> *
COPY 14013 0116   * Copy to transfer register value of Symbolic Link AMOUNT <<116X>> *
COPY 0116 1047   * Get contents of retainer 'date and year' <<116E>> *
COPY 0117 0116   * Copy default string to result register <<117E 116X>> *
COPY 0116 0117   * Save the result of the formatting <<116E 117X>> *
COPY 14012 0116   * Copy to transfer register value of Symbolic Link item no <<116X>> *
COPY 0116 1049   * Get contents of retainer 'account number' <<116E>> *
COPY 0117 0116   * Copy default string to result register <<117E 116X>> *
COPY 0116 0117   * Save the result of the formatting <<116E 117X>> *
COPY 14011 0116   * Copy to transfer register value of Symbolic Link Account <<116X>> *
STON 0116 -00.047   * Use RelY minus Direction Offset <<116E>> *
ICOP 0120 19828   * Copy indirectly the value of the last Y offset <<120E>> *
ADD  0120 0120 19826   * Add direction offset <<120E>> *
ADD  0119 0116 0120   * Add it to current Y offset <<119E 116X 120X>> *
OUTF 0999 0032 =SCPP  000.800  %Rg007.30119////   * Use absX ( no rel ) Use relY  *
CLSD 1002 011   * Call appropriate member of the firm data library *
SKIP 1092 0001   * Check to see if the iteration has been started. *
JUMP 0004  * If iteration not started, do not terminate it. *
OUTF 0999 0011 =ECBB 01091   * End calc of print region of iteration size (eg a single 'it') *
STON 1091 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( but use default ) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1093 0039   * Save the current Y offset *
STON 19828 1093   * Set Y offset reg to last used *
STON 0116 034   * Since iterating 'while tag is same', set up proper condition with our tag id *
NEQ  0118 0116 0045   * against the tag of the next input record *
SKIP 0118 0001   * Skip if we are at end of current it. *
RETN  * Not the end of iter, so return. *
STON 0116 034   * Store the id of the iteration tag <<116E>> *
NEQ  0117 0116 0045   * Compare id of tag of next input record is this iteration tag <<117E 116X>> *
SKIP 0117 0001   * Skip if this is the last iteration *
RETN  * Return if this is not the last iteration *
STON 1092 0000   * Reset marker so next time iteration is encountered, we know it is the 'first' time. *
CALL 0997   * Journal page rule. *
OUTF 0999 0005 =SNP    * New logical page. *
STON 19819 0000   * Reset IEL flag. *
CALL 0995  *
STON 1006 000.000   * New iteration Y offset. *
STON 1016 000.000   * New iteration Y offset. *
STON 1028 000.000   * New iteration Y offset. *
STON 1030 000.000   * New iteration Y offset. *
STON 1033 000.000   * New iteration Y offset. *
STON 1035 000.000   * New iteration Y offset. *
STON 1041 000.000   * New iteration Y offset. *
STON 1044 000.000   * New iteration Y offset. *
STON 1052 000.000   * New iteration Y offset. *
STON 1054 000.000   * New iteration Y offset. *
STON 1056 000.000   * New iteration Y offset. *
STON 1059 000.000   * New iteration Y offset. *
STON 1061 000.000   * New iteration Y offset. *
STON 1065 000.000   * New iteration Y offset. *
STON 1067 000.000   * New iteration Y offset. *
STON 1070 000.000   * New iteration Y offset. *
STON 1075 000.000   * New iteration Y offset. *
STON 1079 000.000   * New iteration Y offset. *
STON 1081 000.000   * New iteration Y offset. *
STON 1084 000.000   * New iteration Y offset. *
STON 1087 000.000   * New iteration Y offset. *
STON 1089 000.000   * New iteration Y offset. *
STON 1093 000.000   * New iteration Y offset. *
INCR 0993   * Increment the no of pages *
INCR 19820   * Increment the real no of pages *
INCR 19807   * Increment the total no of pages. *
STOR 0116 0009     Page   *
CHRS 0117 0002 00 01   * Copy the environment <<117E>> *
ADD  0116 0116 0117   * Concatenate the two strings. <<116E 117X>> *
COPY 0117 0116   * Right justified, String *
COPY 0116 0117   * Concatenate the references <<116E 117X>> *
COPY 0117 0116   * Copy default string to result register <<117E 116X>> *
COPY 0116 0117   * Save the result of the formatting <<116E 117X>> *
COPY 14012 0116   * Copy to transfer register value of Symbolic Link Page Number <<116X>> *
COPY 0116 1013   * Get contents of retainer 'account number a' <<116E>> *
COPY 0117 0116   * Copy default string to result register <<117E 116X>> *
COPY 0116 0117   * Concatenate the references <<116E 117X>> *
COPY 0117 0116   * Copy default string to result register <<117E 116X>> *
COPY 0116 0117   * Save the result of the formatting <<116E 117X>> *
COPY 14011 0116   * Copy to transfer register value of Symbolic Link Account number <<116X>> *
OUTF 0999 0023 =SCPP  005.000  000.200   * Use absX Use absY  *
OUTF 0999 0005 =BTDC *
CLSD 1002 000   * Call appropriate member of the firm data library *
OUTF 0999 0005 =ETDC *
COPY 19829 0114   * After ite restore offset X reg value *
COPY 19827 0115   * After ite restore X direction offset  *
COPY 19828 0112   * After ite restore offset Y reg value *
COPY 19826 0113   * After ite restore Y direction offset  *
JUMP 0000  * Acts as a ENDIF to the end of iteration code *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0110   * Restore Y direction offset to appropriate context *
COPY 19829 0108   * After mc2 restore offset X reg value *
COPY 19827 0109   * After mc2 restore X direction offset  *
COPY 19828 0106   * After mc2 restore offset Y reg value *
COPY 19826 0107   * After mc2 restore Y direction offset  *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0104   * Restore Y direction offset to appropriate context *
COPY 19829 0102   * After mc2 restore offset X reg value *
COPY 19827 0103   * After mc2 restore X direction offset  *
STON 19828 0000   * Reset last Y offset register since relativity has ended *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 504 for 'SUBDIS    '
*******
OUTPUT 031 001  *  Output command bin *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 505 for 'SUBCFO    '
*******
OUTPUT 029 094  *  Output command bin *
SKIP 1086 0056   * Skip if not first time *
STON 1086 0001   * First time, so set absolute position *
COPY 0110 19828   * Before ite save Y offset reg value <<110E>> *
COPY 0111 19826   * Before ite save Y direction offset <<111E>> *
COPY 0112 19829   * Before ite save X offset reg value <<112E>> *
COPY 0113 19827   * Before ite save X direction offset <<113E>> *
SKIP 1082 0005   * If an anchor value was set, skip over initialisation *
SKIP 19828 0002   * Skip if there is a previous Y offset value *
STON 1081 001.800   * Init South Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1081 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.253   * Store direction offset South *
STON 19828 1081   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0105   * Restore X direction offset to appropriate context *
COPY 0106 19828   * Before mc2 save Y offset reg value <<106E>> *
COPY 0107 19826   * Before mc2 save Y direction offset <<107E>> *
COPY 0108 19829   * Before mc2 save X offset reg value <<108E>> *
COPY 0109 19827   * Before mc2 save X direction offset <<109E>> *
JNZ  0002 1083   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01083   * Start calc Relative positioning anchor *
STON 1083 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1084 002.200   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1084 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1084   * Set Y offset reg to last used *
SKIP 19828 0002   * Skip if active Y offset *
STON 1087 002.200   * Init Iteration Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1087 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.253   * Direction offset South iteration *
STON 19828 1087   * Set Y offset reg to last used *
JNZ  0002 1088   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01088   * Start calc Relative positioning anchor *
STON 1088 0001   * Set flag :  calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1089 002.200   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1089 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1089   * Set Y offset reg to last used *
OUTF 0999 0023 =SCPP  000.800  002.200   * Use absX Use absY  *
CLSD 1002 012   * Call appropriate member of the firm data library *
STOR 0114 0001    *
COPY 0115 0114   * Copy default string to result register <<115E 114X>> *
COPY 0114 0115   * Save the result of the formatting <<114E 115X>> *
COPY 14011 0114   * Copy to transfer register value of Symbolic Link Address <<114X>> *
OUTF 0999 0023 =SCPP  000.800  002.800   * Use absX Use absY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
OUTF 0999 0011 =ECBB 01088   * End calc Relative Positioning anchor *
STON 1088 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1089 0039   * Save the current Y offset *
STON 19826 000.053   * Store direction Y offset *
STON 19828 1089   * Set Y offset reg to last used *
JUMP 0001  * Jump over direction offset clear during 1st ite *
STON 19826 000.000   * Clear direction offset for South iteration control *
JNZ  0002 1085   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01085   * Iteration print region. *
STON 1085 0001   * Set flag :  calc box has already started *
SKIP 1086 0001   * Check to see if the iteration has been started. *
JUMP 0004  * If iteration not started, do not terminate it. *
OUTF 0999 0011 =ECBB 01085   * End calc of print region of iteration size (eg a single 'it') *
STON 1085 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( but use default ) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1089 0039   * Save the current Y offset *
STON 19828 1089   * Set Y offset reg to last used *
STON 0114 030   * Since iterating 'while tag is same', set up proper condition with our tag id *
NEQ  0116 0114 0045   * against the tag of the next input record *
SKIP 0116 0001   * Skip if we are at end of current it. *
RETN  * Not the end of iter, so return. *
STON 0114 030   * Store the id of the iteration tag <<114E>> *
NEQ  0115 0114 0045   * Compare id of tag of next input record is this iteration tag <<115E 114X>> *
SKIP 0115 0001   * Skip if this is the last iteration *
RETN  * Return if this is not the last iteration *
STON 1086 0000   * Reset marker so next time iteration is encountered, we know it is the 'first' time. *
COPY 19829 0112   * After ite restore offset X reg value *
COPY 19827 0113   * After ite restore X direction offset  *
COPY 19828 0110   * After ite restore offset Y reg value *
COPY 19826 0111   * After ite restore Y direction offset  *
JUMP 0000  * Acts as a ENDIF to the end of iteration code *
OUTF 0999 0011 =ECBB 01083   * End calc Relative Positioning anchor *
STON 1083 0000   * Clear flag :  calc box has already started *
COPY 0110 19826   * Save Y direction offset for later restoration *
COPY 0111 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1084 0039   * Save the current Y offset *
STON 19826 000.000   * Store direction Y offset *
STON 19828 1084   * Set Y offset reg to last used *
STON 1090 0000   * Set flag :  anchor value was set *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 506 for 'SUBTOT    '
*******
OUTPUT 027 029  *  Output command bin *
COPY 0100 19828   * Before mc2 save Y offset reg value <<100E>> *
COPY 0101 19826   * Before mc2 save Y direction offset <<101E>> *
COPY 0102 19829   * Before mc2 save X offset reg value <<102E>> *
COPY 0103 19827   * Before mc2 save X direction offset <<103E>> *
JNZ  0002 1080   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01080   * Start calc Relative positioning anchor *
STON 1080 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1081 001.800   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1081 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1081   * Set Y offset reg to last used *
STOR 0104 0001    *
COPY 0105 0104   * Copy default string to result register <<105E 104X>> *
COPY 0104 0105   * Save the result of the formatting <<104E 105X>> *
COPY 14011 0104   * Copy to transfer register value of Symbolic Link Address <<104X>> *
OUTF 0999 0023 =SCPP  001.200  001.800   * Use absX Use absY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
OUTF 0999 0011 =ECBB 01080   * End calc Relative Positioning anchor *
STON 1080 0000   * Clear flag :  calc box has already started *
COPY 0104 19826   * Save Y direction offset for later restoration *
COPY 0105 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1081 0039   * Save the current Y offset *
STON 19826 000.253   * Store direction Y offset *
STON 19828 1081   * Set Y offset reg to last used *
STON 1082 0000   * Set flag :  anchor value was set *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 507 for 'SUBNAM    '
*******
OUTPUT 025 124  *  Output command bin *
SKIP 1078 0012   * Skip if not first time *
STON 1078 0001   * First time, so set absolute position *
COPY 0100 19828   * Before ite save Y offset reg value <<100E>> *
COPY 0101 19826   * Before ite save Y direction offset <<101E>> *
COPY 0102 19829   * Before ite save X offset reg value <<102E>> *
COPY 0103 19827   * Before ite save X direction offset <<103E>> *
SKIP 19828 0002   * Skip if active Y offset *
STON 1079 000.000   * Init Iteration Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1079 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.000   * Direction offset South iteration *
STON 19828 1079   * Set Y offset reg to last used *
JUMP 0001  * Jump over direction offset clear during 1st ite *
STON 19826 000.000   * Clear direction offset for South iteration control *
JNZ  0002 1077   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01077   * Iteration print region. *
STON 1077 0001   * Set flag :  calc box has already started *
COPY 0104 15002   * Copy field into work register <<104E>> *
STOR 0105 0018 PIN_FLD_FIRST_NAME  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0015 0105   * Jump if condition 'FIRST NAME' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1007 0105   * Store Retainer value for 'first name'. *
COPY 0105 1007   * Get contents of retainer 'first name' <<105E>> *
STOR 0106 0001    *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
COPY 0106 1008   * Get contents of retainer 'last name' <<106E>> *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
COPY 0106 0105   * Copy default string to result register <<106E 105X>> *
COPY 0105 0106   * Concatenate the references <<105E 106X>> *
COPY 0106 0105   * Copy default string to result register <<106E 105X>> *
COPY 0105 0106   * Save the result of the formatting <<105E 106X>> *
COPY 14011 0105   * Copy to transfer register value of Symbolic Link Address <<105X>> *
OUTF 0999 0023 =SCPP  006.000  001.000   * Use absX Use absY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
JUMP 0066  * Jump to end of the case statement *
STOR 0105 0015 PIN_FLD_ADDRESS  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0011 0105   * Jump if condition 'ADDRESS' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 0106 0105   * Copy default string to result register <<106E 105X>> *
COPY 0105 0106   * Save the result of the formatting <<105E 106X>> *
COPY 14011 0105   * Copy to transfer register value of Symbolic Link Address <<105X>> *
STON 0105 000.000   * Use RelY minus Direction Offset <<105E>> *
ICOP 0109 19828   * Copy indirectly the value of the last Y offset <<109E>> *
ADD  0109 0109 19826   * Add direction offset <<109E>> *
ADD  0108 0105 0109   * Add it to current Y offset <<108E 105X 109X>> *
OUTF 0999 0032 =SCPP  006.000  %Rg007.30108////   * Use absX ( no rel ) Use relY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
JUMP 0052  * Jump to end of the case statement *
STOR 0105 0012 PIN_FLD_CITY  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0003 0105   * Jump if condition 'CITY, STATE, ZIP' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1010 0105   * Store Retainer value for 'CITY'. *
JUMP 0046  * Jump to end of the case statement *
STOR 0105 0013 PIN_FLD_STATE  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0003 0105   * Jump if condition 'STATE' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1011 0105   * Store Retainer value for 'STATE'. *
JUMP 0040  * Jump to end of the case statement *
STOR 0105 0011 PIN_FLD_ZIP  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0023 0105   * Jump if condition 'ZIP' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1012 0105   * Store Retainer value for 'ZIP'. *
COPY 0105 1010   * Get contents of retainer 'CITY' <<105E>> *
STOR 0106 0001    *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
COPY 0106 1011   * Get contents of retainer 'STATE' <<106E>> *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
STOR 0106 0001    *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
COPY 0106 1012   * Get contents of retainer 'ZIP' <<106E>> *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
COPY 0106 0105   * Copy default string to result register <<106E 105X>> *
COPY 0105 0106   * Concatenate the references <<105E 106X>> *
COPY 0106 0105   * Copy default string to result register <<106E 105X>> *
COPY 0105 0106   * Save the result of the formatting <<105E 106X>> *
COPY 14011 0105   * Copy to transfer register value of Symbolic Link Address <<105X>> *
STON 0105 000.000   * Use RelY minus Direction Offset <<105E>> *
ICOP 0109 19828   * Copy indirectly the value of the last Y offset <<109E>> *
ADD  0109 0109 19826   * Add direction offset <<109E>> *
ADD  0108 0105 0109   * Add it to current Y offset <<108E 105X 109X>> *
OUTF 0999 0032 =SCPP  006.000  %Rg007.30108////   * Use absX ( no rel ) Use relY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
JUMP 0014  * Jump to end of the case statement *
STOR 0105 0017 PIN_FLD_LAST_NAME  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0003 0105   * Jump if condition 'LAST NAME' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1008 0105   * Store Retainer value for 'last name'. *
JUMP 0008  * Jump to end of the case statement *
STOR 0105 0018 PIN_FLD_ACCOUNT_NO  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0003 0105   * Jump if condition 'account number' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1049 0105   * Store Retainer value for 'account number'. *
JUMP 0002  * Jump to end of the case statement *
STON 0104 0001   * <<104E>> *
JUMP 0000  * Final NOP for case statement *
SKIP 1078 0001   * Check to see if the iteration has been started. *
JUMP 0004  * If iteration not started, do not terminate it. *
OUTF 0999 0011 =ECBB 01077   * End calc of print region of iteration size (eg a single 'it') *
STON 1077 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( but use default ) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1079 0039   * Save the current Y offset *
STON 19828 1079   * Set Y offset reg to last used *
STON 0104 026   * Since iterating 'while tag is same', set up proper condition with our tag id *
NEQ  0106 0104 0045   * against the tag of the next input record *
SKIP 0106 0001   * Skip if we are at end of current it. *
RETN  * Not the end of iter, so return. *
STON 0104 026   * Store the id of the iteration tag <<104E>> *
NEQ  0105 0104 0045   * Compare id of tag of next input record is this iteration tag <<105E 104X>> *
SKIP 0105 0001   * Skip if this is the last iteration *
RETN  * Return if this is not the last iteration *
STON 1078 0000   * Reset marker so next time iteration is encountered, we know it is the 'first' time. *
COPY 19829 0102   * After ite restore offset X reg value *
COPY 19827 0103   * After ite restore X direction offset  *
STON 19828 0000   * Reset last Y offset register since relativity has ended *
JUMP 0000  * Acts as a ENDIF to the end of iteration code *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 508 for 'PARUSG    '
*******
OUTPUT 022 348  *  Output command bin *
SKIP 1050 0005   * If an anchor value was set, skip over initialisation *
SKIP 19828 0002   * Skip if there is a previous Y offset value *
STON 1041 003.000   * Init South Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1041 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.000   * Store direction offset South *
STON 19828 1041   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0117   * Restore X direction offset to appropriate context *
SKIP 1058 0121   * Skip if not first time *
STON 1058 0001   * First time, so set absolute position *
COPY 0134 19828   * Before ite save Y offset reg value <<134E>> *
COPY 0135 19826   * Before ite save Y direction offset <<135E>> *
COPY 0136 19829   * Before ite save X offset reg value <<136E>> *
COPY 0137 19827   * Before ite save X direction offset <<137E>> *
COPY 0118 19828   * Before mc2 save Y offset reg value <<118E>> *
COPY 0119 19826   * Before mc2 save Y direction offset <<119E>> *
COPY 0120 19829   * Before mc2 save X offset reg value <<120E>> *
COPY 0121 19827   * Before mc2 save X direction offset <<121E>> *
JNZ  0002 1051   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01051   * Start calc Relative positioning anchor *
STON 1051 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1052 000.000   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1052 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1052   * Set Y offset reg to last used *
CALL 0997   * Journal page rule. *
OUTF 0999 0005 =SNP    * New logical page. *
STON 19819 0000   * Reset IEL flag. *
CALL 0995  *
STON 1006 000.000   * New iteration Y offset. *
STON 1016 000.000   * New iteration Y offset. *
STON 1028 000.000   * New iteration Y offset. *
STON 1030 000.000   * New iteration Y offset. *
STON 1033 000.000   * New iteration Y offset. *
STON 1035 000.000   * New iteration Y offset. *
STON 1041 000.000   * New iteration Y offset. *
STON 1044 000.000   * New iteration Y offset. *
STON 1052 000.000   * New iteration Y offset. *
INCR 0993   * Increment the no of pages *
INCR 19820   * Increment the real no of pages *
INCR 19807   * Increment the total no of pages. *
OUTF 0999 0011 =ECBB 01051   * End calc Relative Positioning anchor *
STON 1051 0000   * Clear flag :  calc box has already started *
COPY 0122 19826   * Save Y direction offset for later restoration *
COPY 0123 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1052 0039   * Save the current Y offset *
STON 19826 000.000   * Store direction Y offset *
STON 19828 1052   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0123   * Restore X direction offset to appropriate context *
COPY 0124 19828   * Before mc2 save Y offset reg value <<124E>> *
COPY 0125 19826   * Before mc2 save Y direction offset <<125E>> *
COPY 0126 19829   * Before mc2 save X offset reg value <<126E>> *
COPY 0127 19827   * Before mc2 save X direction offset <<127E>> *
JNZ  0002 1053   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01053   * Start calc Relative positioning anchor *
STON 1053 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1054 000.000   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1054 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1054   * Set Y offset reg to last used *
STOR 0128 0009     Page   *
CHRS 0129 0002 00 01   * Copy the environment <<129E>> *
ADD  0128 0128 0129   * Concatenate the two strings. <<128E 129X>> *
COPY 0129 0128   * Right justified, String *
COPY 0128 0129   * Concatenate the references <<128E 129X>> *
COPY 0129 0128   * Copy default string to result register <<129E 128X>> *
COPY 0128 0129   * Save the result of the formatting <<128E 129X>> *
COPY 14012 0128   * Copy to transfer register value of Symbolic Link Page Number <<128X>> *
COPY 0128 1013   * Get contents of retainer 'account number a' <<128E>> *
COPY 0129 0128   * Copy default string to result register <<129E 128X>> *
COPY 0128 0129   * Concatenate the references <<128E 129X>> *
COPY 0129 0128   * Copy default string to result register <<129E 128X>> *
COPY 0128 0129   * Save the result of the formatting <<128E 129X>> *
COPY 14011 0128   * Copy to transfer register value of Symbolic Link Account number <<128X>> *
OUTF 0999 0023 =SCPP  005.000  000.200   * Use absX Use absY  *
OUTF 0999 0005 =BTDC *
CLSD 1002 000   * Call appropriate member of the firm data library *
OUTF 0999 0005 =ETDC *
OUTF 0999 0011 =ECBB 01053   * End calc Relative Positioning anchor *
STON 1053 0000   * Clear flag :  calc box has already started *
COPY 0128 19826   * Save Y direction offset for later restoration *
COPY 0129 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1054 0039   * Save the current Y offset *
STON 19826 000.000   * Store direction Y offset *
STON 19828 1054   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0129   * Restore X direction offset to appropriate context *
COPY 0130 19828   * Before mc2 save Y offset reg value <<130E>> *
COPY 0131 19826   * Before mc2 save Y direction offset <<131E>> *
COPY 0132 19829   * Before mc2 save X offset reg value <<132E>> *
COPY 0133 19827   * Before mc2 save X direction offset <<133E>> *
JNZ  0002 1055   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01055   * Start calc Relative positioning anchor *
STON 1055 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1056 002.200   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1056 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1056   * Set Y offset reg to last used *
SKIP 19828 0002   * Skip if active Y offset *
STON 1059 002.200   * Init Iteration Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1059 19828   * Copy indirectly the value of the last Y offset *
STON 19826 -00.947   * Direction offset South iteration *
STON 19828 1059   * Set Y offset reg to last used *
JNZ  0002 1060   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01060   * Start calc Relative positioning anchor *
STON 1060 0001   * Set flag :  calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1061 002.200   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1061 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1061   * Set Y offset reg to last used *
OUTF 0999 0023 =SCPP  000.800  002.200   * Use absX Use absY  *
CLSD 1002 016   * Call appropriate member of the firm data library *
OUTF 0999 0011 =ECBB 01060   * End calc Relative Positioning anchor *
STON 1060 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1061 0039   * Save the current Y offset *
STON 19826 000.037   * Store direction Y offset *
STON 19828 1061   * Set Y offset reg to last used *
JUMP 0001  * Jump over direction offset clear during 1st ite *
STON 19826 000.000   * Clear direction offset for South iteration control *
JNZ  0002 1057   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01057   * Iteration print region. *
STON 1057 0001   * Set flag :  calc box has already started *
COPY 0138 15002   * Copy field into work register <<138E>> *
STOR 0139 0015 PIN_FLD_ITEM_NO  *
EQ   0139 0139 0138   * <<139E 138X>> *
JZ   0003 0139   * Jump if condition 'ITEM_NO' is not true. *
COPY 0139 15001   * Copy field into work register <<139E>> *
COPY 1062 0139   * Store Retainer value for 'Item_no_parusg'. *
JUMP 0171  * Jump to end of the case statement *
STOR 0139 0018 PIN_FLD_ITEM_TOTAL  *
EQ   0139 0139 0138   * <<139E 138X>> *
JZ   0160 0139   * Jump if condition 'total' is not true. *
COPY 0139 15001   * Copy field into work register <<139E>> *
COPY 1063 0139   * Store Retainer value for 'item_total'. *
COPY 0139 19828   * Before mc2 save Y offset reg value <<139E>> *
COPY 0140 19826   * Before mc2 save Y direction offset <<140E>> *
COPY 0141 19829   * Before mc2 save X offset reg value <<141E>> *
COPY 0142 19827   * Before mc2 save X direction offset <<142E>> *
JNZ  0002 1064   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01064   * Start calc Relative positioning anchor *
STON 1064 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1065 002.900   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1065 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1065   * Set Y offset reg to last used *
COPY 0143 1037   * Get contents of retainer 'summary cycle forward' <<143E>> *
COPY 0144 0143   * Copy default string to result register <<144E 143X>> *
COPY 0143 0144   * Save the result of the formatting <<143E 144X>> *
COPY 14013 0143   * Copy to transfer register value of Symbolic Link AMOUNT <<143X>> *
COPY 0143 1036   * Get contents of retainer 'item no' <<143E>> *
COPY 0144 0143   * Copy default string to result register <<144E 143X>> *
COPY 0143 0144   * Save the result of the formatting <<143E 144X>> *
COPY 14012 0143   * Copy to transfer register value of Symbolic Link item no <<143X>> *
STOR 0143 0001    *
COPY 0144 0143   * Copy default string to result register <<144E 143X>> *
COPY 0143 0144   * Save the result of the formatting <<143E 144X>> *
COPY 14011 0143   * Copy to transfer register value of Symbolic Link Account <<143X>> *
COPY 0143 1038   * Get contents of retainer 'Pin fld name' <<143E>> *
COPY 0144 0143   * Copy default string to result register <<144E 143X>> *
COPY 0143 0144   * Save the result of the formatting <<143E 144X>> *
COPY 14014 0143   * Copy to transfer register value of Symbolic Link Description <<143X>> *
OUTF 0999 0023 =SCPP  000.800  002.900   * Use absX Use absY  *
CLSD 1002 011   * Call appropriate member of the firm data library *
OUTF 0999 0011 =ECBB 01064   * End calc Relative Positioning anchor *
STON 1064 0000   * Clear flag :  calc box has already started *
COPY 0143 19826   * Save Y direction offset for later restoration *
COPY 0144 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1065 0039   * Save the current Y offset *
STON 19826 000.037   * Store direction Y offset *
STON 19828 1065   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0144   * Restore X direction offset to appropriate context *
COPY 0145 19828   * Before mc2 save Y offset reg value <<145E>> *
COPY 0146 19826   * Before mc2 save Y direction offset <<146E>> *
COPY 0147 19829   * Before mc2 save X offset reg value <<147E>> *
COPY 0148 19827   * Before mc2 save X direction offset <<148E>> *
JNZ  0002 1066   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01066   * Start calc Relative positioning anchor *
STON 1066 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1067 003.100   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1067 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1067   * Set Y offset reg to last used *
COPY 0149 1063   * Get contents of retainer 'item_total' <<149E>> *
ATOF 0150 0149   * Convert string to a number. <<150E 149X>> *
COPY 0149 0150   * Copy converted result back to register <<149E 150X>> *
STOR 0150 0021 %Lf000020149$ /$ -///   * Left justified, Number (thou sep) *
COPY 0149 0150   * Save the result of the formatting <<149E 150X>> *
COPY 14013 0149   * Copy to transfer register value of Symbolic Link AMOUNT <<149X>> *
COPY 0149 1062   * Get contents of retainer 'Item_no_parusg' <<149E>> *
COPY 0150 0149   * Copy default string to result register <<150E 149X>> *
COPY 0149 0150   * Save the result of the formatting <<149E 150X>> *
COPY 14012 0149   * Copy to transfer register value of Symbolic Link item no <<149X>> *
STOR 0149 0001    *
COPY 0150 0149   * Copy default string to result register <<150E 149X>> *
COPY 0149 0150   * Save the result of the formatting <<149E 150X>> *
COPY 14011 0149   * Copy to transfer register value of Symbolic Link Account <<149X>> *
COPY 0149 1068   * Get contents of retainer 'pin fld name 1' <<149E>> *
COPY 0150 0149   * Copy default string to result register <<150E 149X>> *
COPY 0149 0150   * Save the result of the formatting <<149E 150X>> *
COPY 14014 0149   * Copy to transfer register value of Symbolic Link Description <<149X>> *
STON 0149 000.000   * Use RelY minus Direction Offset <<149E>> *
ICOP 0153 19828   * Copy indirectly the value of the last Y offset <<153E>> *
ADD  0153 0153 19826   * Add direction offset <<153E>> *
ADD  0152 0149 0153   * Add it to current Y offset <<152E 149X 153X>> *
OUTF 0999 0032 =SCPP  000.800  %Rg007.30152////   * Use absX ( no rel ) Use relY  *
CLSD 1002 011   * Call appropriate member of the firm data library *
OUTF 0999 0011 =ECBB 01066   * End calc Relative Positioning anchor *
STON 1066 0000   * Clear flag :  calc box has already started *
COPY 0149 19826   * Save Y direction offset for later restoration *
COPY 0150 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1067 0039   * Save the current Y offset *
STON 19826 000.237   * Store direction Y offset *
STON 19828 1067   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0150   * Restore X direction offset to appropriate context *
COPY 0151 19828   * Before mc2 save Y offset reg value <<151E>> *
COPY 0152 19826   * Before mc2 save Y direction offset <<152E>> *
COPY 0153 19829   * Before mc2 save X offset reg value <<153E>> *
COPY 0154 19827   * Before mc2 save X direction offset <<154E>> *
JNZ  0002 1069   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01069   * Start calc Relative positioning anchor *
STON 1069 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1070 003.500   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1070 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1070   * Set Y offset reg to last used *
STON 0155 000.000   * Use RelY minus Direction Offset <<155E>> *
ICOP 0159 19828   * Copy indirectly the value of the last Y offset <<159E>> *
ADD  0159 0159 19826   * Add direction offset <<159E>> *
ADD  0158 0155 0159   * Add it to current Y offset <<158E 155X 159X>> *
OUTF 0999 0032 =SCPP  000.800  %Rg007.30158////   * Use absX ( no rel ) Use relY  *
CLSD 1002 012   * Call appropriate member of the firm data library *
OUTF 0999 0011 =ECBB 01069   * End calc Relative Positioning anchor *
STON 1069 0000   * Clear flag :  calc box has already started *
COPY 0155 19826   * Save Y direction offset for later restoration *
COPY 0156 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1070 0039   * Save the current Y offset *
STON 19826 000.100   * Store direction Y offset *
STON 19828 1070   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0156   * Restore X direction offset to appropriate context *
COPY 0157 1045   * Get contents of retainer 'description' <<157E>> *
COPY 0158 0157   * Copy default string to result register <<158E 157X>> *
COPY 0157 0158   * Save the result of the formatting <<157E 158X>> *
COPY 14014 0157   * Copy to transfer register value of Symbolic Link Description <<157X>> *
COPY 0157 1046   * Get contents of retainer 'amount' <<157E>> *
COPY 0158 0157   * Copy default string to result register <<158E 157X>> *
COPY 0157 0158   * Save the result of the formatting <<157E 158X>> *
COPY 14013 0157   * Copy to transfer register value of Symbolic Link AMOUNT <<157X>> *
COPY 0157 1047   * Get contents of retainer 'date and year' <<157E>> *
COPY 0158 0157   * Copy default string to result register <<158E 157X>> *
COPY 0157 0158   * Save the result of the formatting <<157E 158X>> *
COPY 14012 0157   * Copy to transfer register value of Symbolic Link item no <<157X>> *
COPY 0157 1013   * Get contents of retainer 'account number a' <<157E>> *
COPY 0158 0157   * Copy default string to result register <<158E 157X>> *
COPY 0157 0158   * Save the result of the formatting <<157E 158X>> *
COPY 14011 0157   * Copy to transfer register value of Symbolic Link Account <<157X>> *
STON 0157 000.000   * Use RelY minus Direction Offset <<157E>> *
ICOP 0161 19828   * Copy indirectly the value of the last Y offset <<161E>> *
ADD  0161 0161 19826   * Add direction offset <<161E>> *
ADD  0160 0157 0161   * Add it to current Y offset <<160E 157X 161X>> *
OUTF 0999 0032 =SCPP  000.800  %Rg007.30160////   * Use absX ( no rel ) Use relY  *
CLSD 1002 011   * Call appropriate member of the firm data library *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0155   * Restore Y direction offset to appropriate context *
COPY 19829 0153   * After mc2 restore offset X reg value *
COPY 19827 0154   * After mc2 restore X direction offset  *
COPY 19828 0151   * After mc2 restore offset Y reg value *
COPY 19826 0152   * After mc2 restore Y direction offset  *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0149   * Restore Y direction offset to appropriate context *
COPY 19829 0147   * After mc2 restore offset X reg value *
COPY 19827 0148   * After mc2 restore X direction offset  *
COPY 19828 0145   * After mc2 restore offset Y reg value *
COPY 19826 0146   * After mc2 restore Y direction offset  *
STON 19828 0000   * Set last Y offset reg to 0 now new Y has been processed *
COPY 19826 0143   * Restore Y direction offset to appropriate context *
COPY 19829 0141   * After mc2 restore offset X reg value *
COPY 19827 0142   * After mc2 restore X direction offset  *
COPY 19828 0139   * After mc2 restore offset Y reg value *
COPY 19826 0140   * After mc2 restore Y direction offset  *
JUMP 0008  * Jump to end of the case statement *
STOR 0139 0012 PIN_FLD_NAME  *
EQ   0139 0139 0138   * <<139E 138X>> *
JZ   0003 0139   * Jump if condition 'name' is not true. *
COPY 0139 15001   * Copy field into work register <<139E>> *
COPY 1068 0139   * Store Retainer value for 'pin fld name 1'. *
JUMP 0002  * Jump to end of the case statement *
STON 0138 0001   * <<138E>> *
JUMP 0000  * Final NOP for case statement *
SKIP 1058 0001   * Check to see if the iteration has been started. *
JUMP 0004  * If iteration not started, do not terminate it. *
OUTF 0999 0011 =ECBB 01057   * End calc of print region of iteration size (eg a single 'it') *
STON 1057 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( but use default ) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1061 0039   * Save the current Y offset *
STON 19828 1061   * Set Y offset reg to last used *
STON 0138 023   * Since iterating 'while tag is same', set up proper condition with our tag id *
NEQ  0140 0138 0045   * against the tag of the next input record *
SKIP 0140 0001   * Skip if we are at end of current it. *
RETN  * Not the end of iter, so return. *
STON 0138 023   * Store the id of the iteration tag <<138E>> *
NEQ  0139 0138 0045   * Compare id of tag of next input record is this iteration tag <<139E 138X>> *
SKIP 0139 0001   * Skip if this is the last iteration *
RETN  * Return if this is not the last iteration *
STON 1058 0000   * Reset marker so next time iteration is encountered, we know it is the 'first' time. *
STOR 0138 0002 ON  *
COPY 1071 0138   * Store Retainer value for 'Trigger on'. *
COPY 19829 0136   * After ite restore offset X reg value *
COPY 19827 0137   * After ite restore X direction offset  *
COPY 19828 0134   * After ite restore offset Y reg value *
COPY 19826 0135   * After ite restore Y direction offset  *
JUMP 0000  * Acts as a ENDIF to the end of iteration code *
OUTF 0999 0011 =ECBB 01055   * End calc Relative Positioning anchor *
STON 1055 0000   * Clear flag :  calc box has already started *
COPY 0134 19826   * Save Y direction offset for later restoration *
COPY 0135 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1056 0039   * Save the current Y offset *
STON 19826 000.000   * Store direction Y offset *
STON 19828 1056   * Set Y offset reg to last used *
STON 1072 0000   * Set flag :  anchor value was set *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 509 for 'PARCFOEVEO'
*******
OUTPUT 020 148  *  Output command bin *
SKIP 1039 0005   * If an anchor value was set, skip over initialisation *
SKIP 19828 0002   * Skip if there is a previous Y offset value *
STON 1030 002.200   * Init South Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1030 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.000   * Store direction offset South *
STON 19828 1030   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0111   * Restore X direction offset to appropriate context *
SKIP 1043 0024   * Skip if not first time *
STON 1043 0001   * First time, so set absolute position *
COPY 0116 19828   * Before ite save Y offset reg value <<116E>> *
COPY 0117 19826   * Before ite save Y direction offset <<117E>> *
COPY 0118 19829   * Before ite save X offset reg value <<118E>> *
COPY 0119 19827   * Before ite save X direction offset <<119E>> *
COPY 0112 19828   * Before mc2 save Y offset reg value <<112E>> *
COPY 0113 19826   * Before mc2 save Y direction offset <<113E>> *
COPY 0114 19829   * Before mc2 save X offset reg value <<114E>> *
COPY 0115 19827   * Before mc2 save X direction offset <<115E>> *
JNZ  0002 1040   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01040   * Start calc Relative positioning anchor *
STON 1040 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1041 003.000   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1041 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1041   * Set Y offset reg to last used *
SKIP 19828 0002   * Skip if active Y offset *
STON 1044 000.000   * Init Iteration Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1044 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.000   * Direction offset South iteration *
STON 19828 1044   * Set Y offset reg to last used *
JUMP 0001  * Jump over direction offset clear during 1st ite *
STON 19826 000.000   * Clear direction offset for South iteration control *
JNZ  0002 1042   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01042   * Iteration print region. *
STON 1042 0001   * Set flag :  calc box has already started *
COPY 0120 15002   * Copy field into work register <<120E>> *
TRIM 0120 0120 0002   * Trim the spaces <<120E>> *
COPY 0121 0120   * Left justified, String *
COPY 0120 0121   * Copy back result of formatting <<120E 121X>> *
STOR 0121 0016 PIN_FLD_RATE_TAG  *
EQ   0121 0121 0120   * <<121E 120X>> *
JZ   0003 0121   * Jump if condition '' is not true. *
COPY 0121 15001   * Copy field into work register <<121E>> *
COPY 1045 0121   * Store Retainer value for 'description'. *
JUMP 0037  * Jump to end of the case statement *
STOR 0121 0014 PIN_FLD_AMOUNT  *
EQ   0121 0121 0120   * <<121E 120X>> *
JZ   0003 0121   * Jump if condition '' is not true. *
COPY 0121 15001   * Copy field into work register <<121E>> *
COPY 1046 0121   * Store Retainer value for 'amount'. *
JUMP 0031  * Jump to end of the case statement *
STOR 0121 0013 PIN_FLD_END_T  *
EQ   0121 0121 0120   * <<121E 120X>> *
JZ   0026 0121   * Jump if condition '' is not true. *
COPY 0121 15001   * Copy field into work register <<121E>> *
SUBS 0121 016 003 0121   * Substring <<121E>> *
COPY 1021 0121   * Store Retainer value for 'Month'. *
COPY 0121 15001   * Copy field into work register <<121E>> *
SUBS 0121 020 002 0121   * Substring <<121E>> *
COPY 1022 0121   * Store Retainer value for 'Day'. *
COPY 0121 15001   * Copy field into work register <<121E>> *
SUBS 0121 032 004 0121   * Substring <<121E>> *
COPY 1023 0121   * Store Retainer value for 'Year'. *
COPY 0121 1021   * Get contents of retainer 'Month' <<121E>> *
STOR 0121 0015 @@N%Ls000 121@@  *
MAPP 0121 0121  *
COPY 1024 0121   * Store Retainer value for 'date'. *
COPY 0121 1021   * Get contents of retainer 'Month' <<121E>> *
STOR 0122 0001    *
ADD  0121 0121 0122   * Concatenate the two strings. <<121E 122X>> *
COPY 0122 1022   * Get contents of retainer 'Day' <<122E>> *
ADD  0121 0121 0122   * Concatenate the two strings. <<121E 122X>> *
STOR 0122 0001    *
ADD  0121 0121 0122   * Concatenate the two strings. <<121E 122X>> *
COPY 0122 1023   * Get contents of retainer 'Year' <<122E>> *
ADD  0121 0121 0122   * Concatenate the two strings. <<121E 122X>> *
COPY 0122 0121   * Copy default string to result register <<122E 121X>> *
COPY 0121 0122   * Concatenate the references <<121E 122X>> *
COPY 1047 0121   * Store Retainer value for 'date and year'. *
JUMP 0002  * Jump to end of the case statement *
STON 0120 0001   * <<120E>> *
JUMP 0000  * Final NOP for case statement *
COPY 0120 15002   * Copy field into work register <<120E>> *
TRIM 0120 0120 0002   * Trim the spaces <<120E>> *
COPY 0121 0120   * Left justified, String *
COPY 0120 0121   * Copy back result of formatting <<120E 121X>> *
STOR 0121 0014 PIN_FLD_AMOUNT  *
EQ   0122 0120 0121  *
COPY 1048 0122   * Save result of the condition '' <<122X>> *
JZ   0022 1048   * Jump if condition '' is not true. *
COPY 0120 1045   * Get contents of retainer 'description' <<120E>> *
COPY 0121 0120   * Copy default string to result register <<121E 120X>> *
COPY 0120 0121   * Save the result of the formatting <<120E 121X>> *
COPY 14014 0120   * Copy to transfer register value of Symbolic Link Description <<120X>> *
COPY 0120 1046   * Get contents of retainer 'amount' <<120E>> *
COPY 0121 0120   * Copy default string to result register <<121E 120X>> *
COPY 0120 0121   * Save the result of the formatting <<120E 121X>> *
COPY 14013 0120   * Copy to transfer register value of Symbolic Link AMOUNT <<120X>> *
COPY 0120 1047   * Get contents of retainer 'date and year' <<120E>> *
COPY 0121 0120   * Copy default string to result register <<121E 120X>> *
COPY 0120 0121   * Save the result of the formatting <<120E 121X>> *
COPY 14012 0120   * Copy to transfer register value of Symbolic Link item no <<120X>> *
COPY 0120 1049   * Get contents of retainer 'account number' <<120E>> *
COPY 0121 0120   * Copy default string to result register <<121E 120X>> *
COPY 0120 0121   * Save the result of the formatting <<120E 121X>> *
COPY 14011 0120   * Copy to transfer register value of Symbolic Link Account <<120X>> *
STON 0120 -00.047   * Use RelY minus Direction Offset <<120E>> *
ICOP 0124 19828   * Copy indirectly the value of the last Y offset <<124E>> *
ADD  0124 0124 19826   * Add direction offset <<124E>> *
ADD  0123 0120 0124   * Add it to current Y offset <<123E 120X 124X>> *
OUTF 0999 0032 =SCPP  000.800  %Rg007.30123////   * Use absX ( no rel ) Use relY  *
CLSD 1002 011   * Call appropriate member of the firm data library *
SKIP 1043 0001   * Check to see if the iteration has been started. *
JUMP 0004  * If iteration not started, do not terminate it. *
OUTF 0999 0011 =ECBB 01042   * End calc of print region of iteration size (eg a single 'it') *
STON 1042 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( but use default ) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1044 0039   * Save the current Y offset *
STON 19828 1044   * Set Y offset reg to last used *
STON 0120 021   * Since iterating 'while tag is same', set up proper condition with our tag id *
NEQ  0122 0120 0045   * against the tag of the next input record *
SKIP 0122 0001   * Skip if we are at end of current it. *
RETN  * Not the end of iter, so return. *
STON 0120 021   * Store the id of the iteration tag <<120E>> *
NEQ  0121 0120 0045   * Compare id of tag of next input record is this iteration tag <<121E 120X>> *
SKIP 0121 0001   * Skip if this is the last iteration *
RETN  * Return if this is not the last iteration *
STON 1043 0000   * Reset marker so next time iteration is encountered, we know it is the 'first' time. *
COPY 19829 0118   * After ite restore offset X reg value *
COPY 19827 0119   * After ite restore X direction offset  *
COPY 19828 0116   * After ite restore offset Y reg value *
COPY 19826 0117   * After ite restore Y direction offset  *
JUMP 0000  * Acts as a ENDIF to the end of iteration code *
OUTF 0999 0011 =ECBB 01040   * End calc Relative Positioning anchor *
STON 1040 0000   * Clear flag :  calc box has already started *
COPY 0116 19826   * Save Y direction offset for later restoration *
COPY 0117 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1041 0039   * Save the current Y offset *
STON 19826 000.000   * Store direction Y offset *
STON 19828 1041   * Set Y offset reg to last used *
STON 1050 0000   * Set flag :  anchor value was set *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 510 for 'PARTOT    '
*******
OUTPUT 017 122  *  Output command bin *
SKIP 1015 0012   * Skip if not first time *
STON 1015 0001   * First time, so set absolute position *
COPY 0100 19828   * Before ite save Y offset reg value <<100E>> *
COPY 0101 19826   * Before ite save Y direction offset <<101E>> *
COPY 0102 19829   * Before ite save X offset reg value <<102E>> *
COPY 0103 19827   * Before ite save X direction offset <<103E>> *
SKIP 19828 0002   * Skip if active Y offset *
STON 1016 000.000   * Init Iteration Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1016 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.000   * Direction offset South iteration *
STON 19828 1016   * Set Y offset reg to last used *
JUMP 0001  * Jump over direction offset clear during 1st ite *
STON 19826 000.000   * Clear direction offset for South iteration control *
JNZ  0002 1014   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01014   * Iteration print region. *
STON 1014 0001   * Set flag :  calc box has already started *
COPY 0104 15002   * Copy field into work register <<104E>> *
STOR 0105 0022 PIN_FLD_PREVIOUS_TOTAL  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0013 0105   * Jump if condition '' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
ATOF 0106 0105   * Convert string to a number. <<106E 105X>> *
COPY 0105 0106   * Copy converted result back to register <<105E 106X>> *
STOR 0106 0017 %Lg000020105/-///   * Left justified, Number (no thou sep) *
COPY 0105 0106   * Copy back result of formatting <<105E 106X>> *
COPY 1017 0105   * Store Retainer value for 'previous balance a'. *
COPY 0105 15001   * Copy field into work register <<105E>> *
ATOF 0106 0105   * Convert string to a number. <<106E 105X>> *
COPY 0105 0106   * Copy converted result back to register <<105E 106X>> *
STOR 0106 0021 %Lg000020105$ /$ -///   * Left justified, Number (no thou sep) *
COPY 0105 0106   * Copy back result of formatting <<105E 106X>> *
COPY 1018 0105   * Store Retainer value for 'previous balance'. *
JUMP 0066  * Jump to end of the case statement *
STOR 0105 0021 PIN_FLD_CURRENT_TOTAL  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0007 0105   * Jump if condition '' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
ATOF 0106 0105   * Convert string to a number. <<106E 105X>> *
COPY 0105 0106   * Copy converted result back to register <<105E 106X>> *
STOR 0106 0021 %Lg000020105$ /$ -///   * Left justified, Number (no thou sep) *
COPY 0105 0106   * Copy back result of formatting <<105E 106X>> *
COPY 1019 0105   * Store Retainer value for 'current total'. *
JUMP 0056  * Jump to end of the case statement *
STOR 0105 0017 PIN_FLD_TOTAL_DUE  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0007 0105   * Jump if condition '' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
ATOF 0106 0105   * Convert string to a number. <<106E 105X>> *
COPY 0105 0106   * Copy converted result back to register <<105E 106X>> *
STOR 0106 0021 %Lg000020105$ /$ -///   * Left justified, Number (no thou sep) *
COPY 0105 0106   * Copy back result of formatting <<105E 106X>> *
COPY 1020 0105   * Store Retainer value for 'total due'. *
JUMP 0046  * Jump to end of the case statement *
STOR 0105 0013 PIN_FLD_END_T  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0013 0105   * Jump if condition 'date' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
SUBS 0105 016 003 0105   * Substring <<105E>> *
COPY 1021 0105   * Store Retainer value for 'Month'. *
COPY 0105 15001   * Copy field into work register <<105E>> *
SUBS 0105 020 002 0105   * Substring <<105E>> *
COPY 1022 0105   * Store Retainer value for 'Day'. *
COPY 0105 15001   * Copy field into work register <<105E>> *
SUBS 0105 032 004 0105   * Substring <<105E>> *
COPY 1023 0105   * Store Retainer value for 'Year'. *
COPY 0105 15001   * Copy field into work register <<105E>> *
SUBS 0105 012 008 0105   * Substring <<105E>> *
COPY 1024 0105   * Store Retainer value for 'date'. *
JUMP 0030  * Jump to end of the case statement *
STOR 0105 0021 PIN_FLD_SUBORDS_TOTAL  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0025 0105   * Jump if condition '' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
ATOF 0106 0105   * Convert string to a number. <<106E 105X>> *
COPY 0105 0106   * Copy converted result back to register <<105E 106X>> *
STOR 0106 0021 %Lg000020105$ /$ -///   * Left justified, Number (no thou sep) *
COPY 0105 0106   * Copy back result of formatting <<105E 106X>> *
COPY 1025 0105   * Store Retainer value for 'subords total'. *
COPY 0105 1017   * Get contents of retainer 'previous balance a' <<105E>> *
ATOF 0106 0105   * Convert string to a number. <<106E 105X>> *
COPY 0105 0106   * Copy converted result back to register <<105E 106X>> *
COPY 0106 15001   * Copy field into work register <<106E>> *
ATOF 0107 0106   * Convert string to a number. <<107E 106X>> *
COPY 0106 0107   * Copy converted result back to register <<106E 107X>> *
STOR 0107 0017 %Lg000020106/-///   * Left justified, Number (no thou sep) *
COPY 0106 0107   * Copy back result of formatting <<106E 107X>> *
ATOF 0107 0106   * Convert string to a number. <<107E 106X>> *
COPY 0106 0107   * Copy converted result back to register <<106E 107X>> *
ADD  0105 0105 106   *  <<105E 106X>> *
COPY 0106 1025   * Get contents of retainer 'subords total' <<106E>> *
ATOF 0107 0106   * Convert string to a number. <<107E 106X>> *
COPY 0106 0107   * Copy converted result back to register <<106E 107X>> *
ADD  0105 0105 106   *  <<105E 106X>> *
STOR 0105 0017 %Lg000.2 105/-///   * Convert number to a string. <<105X 105X>> *
COPY 0105 0105   * Copy converted result back <<105X 105X>> *
COPY 1026 0105   * Store Retainer value for 'balance'. *
JUMP 0002  * Jump to end of the case statement *
STON 0104 0001   * <<104E>> *
JUMP 0000  * Final NOP for case statement *
SKIP 1015 0001   * Check to see if the iteration has been started. *
JUMP 0004  * If iteration not started, do not terminate it. *
OUTF 0999 0011 =ECBB 01014   * End calc of print region of iteration size (eg a single 'it') *
STON 1014 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( but use default ) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1016 0039   * Save the current Y offset *
STON 19828 1016   * Set Y offset reg to last used *
STON 0104 018   * Since iterating 'while tag is same', set up proper condition with our tag id *
NEQ  0106 0104 0045   * against the tag of the next input record *
SKIP 0106 0001   * Skip if we are at end of current it. *
RETN  * Not the end of iter, so return. *
STON 0104 018   * Store the id of the iteration tag <<104E>> *
NEQ  0105 0104 0045   * Compare id of tag of next input record is this iteration tag <<105E 104X>> *
SKIP 0105 0001   * Skip if this is the last iteration *
RETN  * Return if this is not the last iteration *
STON 1015 0000   * Reset marker so next time iteration is encountered, we know it is the 'first' time. *
COPY 19829 0102   * After ite restore offset X reg value *
COPY 19827 0103   * After ite restore X direction offset  *
STON 19828 0000   * Reset last Y offset register since relativity has ended *
JUMP 0000  * Acts as a ENDIF to the end of iteration code *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 511 for 'PARCFO    '
*******
OUTPUT 015 289  *  Output command bin *
SKIP 1032 0205   * Skip if not first time *
STON 1032 0001   * First time, so set absolute position *
COPY 0110 19828   * Before ite save Y offset reg value <<110E>> *
COPY 0111 19826   * Before ite save Y direction offset <<111E>> *
COPY 0112 19829   * Before ite save X offset reg value <<112E>> *
COPY 0113 19827   * Before ite save X direction offset <<113E>> *
COPY 0100 1024   * Get contents of retainer 'date' <<100E>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14011 0100   * Copy to transfer register value of Symbolic Link Due date <<100X>> *
OUTF 0999 0023 =SCPP  006.400  000.800   * Use absX Use absY  *
CLSD 1002 001   * Call appropriate member of the firm data library *
COPY 0100 1026   * Get contents of retainer 'balance' <<100E>> *
ATOF 0101 0100   * Convert string to a number. <<101E 100X>> *
COPY 0100 0101   * Copy converted result back to register <<100E 101X>> *
STOR 0101 0021 %Lg000020100$ /$ -///   * Left justified, Number (no thou sep) *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14017 0100   * Copy to transfer register value of Symbolic Link Pbalance <<100X>> *
STOR 0100 0001    *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14016 0100   * Copy to transfer register value of Symbolic Link Pymts <<100X>> *
STOR 0100 0001    *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14015 0100   * Copy to transfer register value of Symbolic Link Adj <<100X>> *
COPY 0100 1019   * Get contents of retainer 'current total' <<100E>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14014 0100   * Copy to transfer register value of Symbolic Link Current charge <<100X>> *
COPY 0100 1020   * Get contents of retainer 'total due' <<100E>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14013 0100   * Copy to transfer register value of Symbolic Link Total <<100X>> *
COPY 0100 1021   * Get contents of retainer 'Month' <<100E>> *
STOR 0101 0001 /  *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 1022   * Get contents of retainer 'Day' <<101E>> *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Concatenate the references <<100E 101X>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14012 0100   * Copy to transfer register value of Symbolic Link Date1 <<100X>> *
COPY 0100 1021   * Get contents of retainer 'Month' <<100E>> *
STOR 0101 0001 /  *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 1022   * Get contents of retainer 'Day' <<101E>> *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Concatenate the references <<100E 101X>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14011 0100   * Copy to transfer register value of Symbolic Link Date <<100X>> *
OUTF 0999 0023 =SCPP  002.200  001.600   * Use absX Use absY  *
CLSD 1002 003   * Call appropriate member of the firm data library *
OUTF 0999 0023 =SCPP  002.900  003.000   * Use absX Use absY  *
CLSD 1002 002   * Call appropriate member of the firm data library *
COPY 0100 1026   * Get contents of retainer 'balance' <<100E>> *
ATOF 0101 0100   * Convert string to a number. <<101E 100X>> *
COPY 0100 0101   * Copy converted result back to register <<100E 101X>> *
STOR 0101 0021 %Lg000020100$ /$ -///   * Left justified, Number (no thou sep) *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14013 0100   * Copy to transfer register value of Symbolic Link Forward <<100X>> *
COPY 0100 1020   * Get contents of retainer 'total due' <<100E>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14012 0100   * Copy to transfer register value of Symbolic Link total <<100X>> *
COPY 0100 1019   * Get contents of retainer 'current total' <<100E>> *
ATOF 0101 0100   * Convert string to a number. <<101E 100X>> *
COPY 0100 0101   * Copy converted result back to register <<100E 101X>> *
STOR 0101 0021 %Lg000020100$ /$ -///   * Left justified, Number (no thou sep) *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14011 0100   * Copy to transfer register value of Symbolic Link Summary <<100X>> *
OUTF 0999 0023 =SCPP  003.000  004.200   * Use absX Use absY  *
CLSD 1002 004   * Call appropriate member of the firm data library *
COPY 0100 1021   * Get contents of retainer 'Month' <<100E>> *
STOR 0101 0001 /  *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 1022   * Get contents of retainer 'Day' <<101E>> *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
STOR 0101 0001 /  *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 1023   * Get contents of retainer 'Year' <<101E>> *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Concatenate the references <<100E 101X>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14011 0100   * Copy to transfer register value of Symbolic Link date 2 <<100X>> *
OUTF 0999 0023 =SCPP  002.800  006.000   * Use absX Use absY  *
CLSD 1002 005   * Call appropriate member of the firm data library *
OUTF 0999 0023 =SCPP  003.200  007.000   * Use absX Use absY  *
CLSD 1002 006   * Call appropriate member of the firm data library *
OUTF 0999 0023 =SCPP  001.200  007.300   * Use absX Use absY  *
CLSD 1002 007   * Call appropriate member of the firm data library *
OUTF 0999 0023 =SCPP  003.200  007.500   * Use absX Use absY  *
CLSD 1002 009   * Call appropriate member of the firm data library *
STOR 0100 0001    *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14013 0100   * Copy to transfer register value of Symbolic Link Aenclosed <<100X>> *
COPY 0100 1020   * Get contents of retainer 'total due' <<100E>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14012 0100   * Copy to transfer register value of Symbolic Link Total amount due <<100X>> *
COPY 0100 1021   * Get contents of retainer 'Month' <<100E>> *
STOR 0101 0001 /  *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 1022   * Get contents of retainer 'Day' <<101E>> *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
STOR 0101 0001 /  *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 1023   * Get contents of retainer 'Year' <<101E>> *
ADD  0100 0100 0101   * Concatenate the two strings. <<100E 101X>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Concatenate the references <<100E 101X>> *
COPY 0101 0100   * Copy default string to result register <<101E 100X>> *
COPY 0100 0101   * Save the result of the formatting <<100E 101X>> *
COPY 14011 0100   * Copy to transfer register value of Symbolic Link Pay By <<100X>> *
OUTF 0999 0023 =SCPP  004.100  008.100   * Use absX Use absY  *
CLSD 1002 014   * Call appropriate member of the firm data library *
OUTF 0999 0023 =SCPP  001.300  007.800   * Use absX Use absY  *
CLSD 1002 015   * Call appropriate member of the firm data library *
OUTF 0999 0023 =SCPP  002.000  008.900   * Use absX Use absY  *
CLSD 1002 010   * Call appropriate member of the firm data library *
CALL 0997   * Journal page rule. *
OUTF 0999 0005 =SNP    * New logical page. *
STON 19819 0000   * Reset IEL flag. *
CALL 0995  *
STON 1006 000.000   * New iteration Y offset. *
STON 1016 000.000   * New iteration Y offset. *
INCR 0993   * Increment the no of pages *
INCR 19820   * Increment the real no of pages *
INCR 19807   * Increment the total no of pages. *
COPY 0100 19828   * Before mc2 save Y offset reg value <<100E>> *
COPY 0101 19826   * Before mc2 save Y direction offset <<101E>> *
COPY 0102 19829   * Before mc2 save X offset reg value <<102E>> *
COPY 0103 19827   * Before mc2 save X direction offset <<103E>> *
JNZ  0002 1027   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01027   * Start calc Relative positioning anchor *
STON 1027 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1028 001.800   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1028 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1028   * Set Y offset reg to last used *
STOR 0104 0001    *
COPY 0105 0104   * Copy default string to result register <<105E 104X>> *
COPY 0104 0105   * Save the result of the formatting <<104E 105X>> *
COPY 14011 0104   * Copy to transfer register value of Symbolic Link Address <<104X>> *
OUTF 0999 0023 =SCPP  001.200  001.800   * Use absX Use absY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
OUTF 0999 0011 =ECBB 01027   * End calc Relative Positioning anchor *
STON 1027 0000   * Clear flag :  calc box has already started *
COPY 0104 19826   * Save Y direction offset for later restoration *
COPY 0105 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1028 0039   * Save the current Y offset *
STON 19826 000.253   * Store direction Y offset *
STON 19828 1028   * Set Y offset reg to last used *
STON 19829 0000   * Reset last X offset reg to 0 new X has been processed *
COPY 19827 0105   * Restore X direction offset to appropriate context *
COPY 0106 19828   * Before mc2 save Y offset reg value <<106E>> *
COPY 0107 19826   * Before mc2 save Y direction offset <<107E>> *
COPY 0108 19829   * Before mc2 save X offset reg value <<108E>> *
COPY 0109 19827   * Before mc2 save X direction offset <<109E>> *
JNZ  0002 1029   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01029   * Start calc Relative positioning anchor *
STON 1029 0001   * Set flag indicated calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1030 002.200   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1030 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1030   * Set Y offset reg to last used *
SKIP 19828 0002   * Skip if active Y offset *
STON 1033 002.200   * Init Iteration Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1033 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.253   * Direction offset South iteration *
STON 19828 1033   * Set Y offset reg to last used *
JNZ  0002 1034   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01034   * Start calc Relative positioning anchor *
STON 1034 0001   * Set flag :  calc box has already started *
SKIP 19828 0002   * Skip if active Y offset *
STON 1035 002.200   * Init Start Group Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1035 19828   * Copy indirectly the value of the last Y offset *
STON 19828 1035   * Set Y offset reg to last used *
OUTF 0999 0023 =SCPP  000.800  002.200   * Use absX Use absY  *
CLSD 1002 012   * Call appropriate member of the firm data library *
STOR 0114 0001    *
COPY 0115 0114   * Copy default string to result register <<115E 114X>> *
COPY 0114 0115   * Save the result of the formatting <<114E 115X>> *
COPY 14011 0114   * Copy to transfer register value of Symbolic Link Address <<114X>> *
OUTF 0999 0023 =SCPP  000.800  002.800   * Use absX Use absY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
OUTF 0999 0011 =ECBB 01034   * End calc Relative Positioning anchor *
STON 1034 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1035 0039   * Save the current Y offset *
STON 19826 000.053   * Store direction Y offset *
STON 19828 1035   * Set Y offset reg to last used *
JUMP 0001  * Jump over direction offset clear during 1st ite *
STON 19826 000.000   * Clear direction offset for South iteration control *
JNZ  0002 1031   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01031   * Iteration print region. *
STON 1031 0001   * Set flag :  calc box has already started *
COPY 0114 15002   * Copy field into work register <<114E>> *
TRIM 0114 0114 0002   * Trim the spaces <<114E>> *
COPY 0115 0114   * Left justified, String *
COPY 0114 0115   * Copy back result of formatting <<114E 115X>> *
STOR 0115 0015 PIN_FLD_ITEM_NO  *
EQ   0115 0115 0114   * <<115E 114X>> *
JZ   0021 0115   * Jump if condition '' is not true. *
COPY 0115 15001   * Copy field into work register <<115E>> *
COPY 1036 0115   * Store Retainer value for 'item no'. *
STOR 0115 0009     Page   *
CHRS 0116 0002 00 01   * Copy the environment <<116E>> *
ADD  0115 0115 0116   * Concatenate the two strings. <<115E 116X>> *
COPY 0116 0115   * Right justified, String *
COPY 0115 0116   * Concatenate the references <<115E 116X>> *
COPY 0116 0115   * Copy default string to result register <<116E 115X>> *
COPY 0115 0116   * Save the result of the formatting <<115E 116X>> *
COPY 14012 0115   * Copy to transfer register value of Symbolic Link Page Number <<115X>> *
COPY 0115 1013   * Get contents of retainer 'account number a' <<115E>> *
COPY 0116 0115   * Copy default string to result register <<116E 115X>> *
COPY 0115 0116   * Concatenate the references <<115E 116X>> *
COPY 0116 0115   * Copy default string to result register <<116E 115X>> *
COPY 0115 0116   * Save the result of the formatting <<115E 116X>> *
COPY 14011 0115   * Copy to transfer register value of Symbolic Link Account number <<115X>> *
OUTF 0999 0023 =SCPP  005.000  000.200   * Use absX Use absY  *
OUTF 0999 0005 =BTDC *
CLSD 1002 000   * Call appropriate member of the firm data library *
OUTF 0999 0005 =ETDC *
JUMP 0018  * Jump to end of the case statement *
STOR 0115 0018 PIN_FLD_ITEM_TOTAL  *
EQ   0115 0115 0114   * <<115E 114X>> *
JZ   0007 0115   * Jump if condition '' is not true. *
COPY 0115 15001   * Copy field into work register <<115E>> *
ATOF 0116 0115   * Convert string to a number. <<116E 115X>> *
COPY 0115 0116   * Copy converted result back to register <<115E 116X>> *
STOR 0116 0021 %Lg000020115$ /$ -///   * Left justified, Number (no thou sep) *
COPY 0115 0116   * Copy back result of formatting <<115E 116X>> *
COPY 1037 0115   * Store Retainer value for 'summary cycle forward'. *
JUMP 0008  * Jump to end of the case statement *
STOR 0115 0012 PIN_FLD_NAME  *
EQ   0115 0115 0114   * <<115E 114X>> *
JZ   0003 0115   * Jump if condition 'name' is not true. *
COPY 0115 15001   * Copy field into work register <<115E>> *
COPY 1038 0115   * Store Retainer value for 'Pin fld name'. *
JUMP 0002  * Jump to end of the case statement *
STON 0114 0001   * <<114E>> *
JUMP 0000  * Final NOP for case statement *
SKIP 1032 0001   * Check to see if the iteration has been started. *
JUMP 0004  * If iteration not started, do not terminate it. *
OUTF 0999 0011 =ECBB 01031   * End calc of print region of iteration size (eg a single 'it') *
STON 1031 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( but use default ) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1035 0039   * Save the current Y offset *
STON 19828 1035   * Set Y offset reg to last used *
STON 0114 016   * Since iterating 'while tag is same', set up proper condition with our tag id *
NEQ  0116 0114 0045   * against the tag of the next input record *
SKIP 0116 0001   * Skip if we are at end of current it. *
RETN  * Not the end of iter, so return. *
STON 0114 016   * Store the id of the iteration tag <<114E>> *
NEQ  0115 0114 0045   * Compare id of tag of next input record is this iteration tag <<115E 114X>> *
SKIP 0115 0001   * Skip if this is the last iteration *
RETN  * Return if this is not the last iteration *
STON 1032 0000   * Reset marker so next time iteration is encountered, we know it is the 'first' time. *
COPY 19829 0112   * After ite restore offset X reg value *
COPY 19827 0113   * After ite restore X direction offset  *
COPY 19828 0110   * After ite restore offset Y reg value *
COPY 19826 0111   * After ite restore Y direction offset  *
JUMP 0000  * Acts as a ENDIF to the end of iteration code *
OUTF 0999 0011 =ECBB 01029   * End calc Relative Positioning anchor *
STON 1029 0000   * Clear flag :  calc box has already started *
COPY 0110 19826   * Save Y direction offset for later restoration *
COPY 0111 19827   * Save X direction offset for later restoration *
SKIP 0041 0001   * Skip saving the height ( and use default) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1030 0039   * Save the current Y offset *
STON 19826 000.000   * Store direction Y offset *
STON 19828 1030   * Set Y offset reg to last used *
STON 1039 0000   * Set flag :  anchor value was set *
INCR 19816  *  Increment the total not of records. *

*******
* Output command bin No: 512 for 'PARNAM    '
*******
OUTPUT 013 126  *  Output command bin *
SKIP 1005 0012   * Skip if not first time *
STON 1005 0001   * First time, so set absolute position *
COPY 0100 19828   * Before ite save Y offset reg value <<100E>> *
COPY 0101 19826   * Before ite save Y direction offset <<101E>> *
COPY 0102 19829   * Before ite save X offset reg value <<102E>> *
COPY 0103 19827   * Before ite save X direction offset <<103E>> *
SKIP 19828 0002   * Skip if active Y offset *
STON 1006 000.000   * Init Iteration Y offset (loop) reg *
JUMP 0001  * Jump over copying from previous offset *
ICOP 1006 19828   * Copy indirectly the value of the last Y offset *
STON 19826 000.000   * Direction offset South iteration *
STON 19828 1006   * Set Y offset reg to last used *
JUMP 0001  * Jump over direction offset clear during 1st ite *
STON 19826 000.000   * Clear direction offset for South iteration control *
JNZ  0002 1004   * Jump over start calc box if already started *
OUTF 0999 0011 =SCBB 01004   * Iteration print region. *
STON 1004 0001   * Set flag :  calc box has already started *
COPY 0104 15002   * Copy field into work register <<104E>> *
STOR 0105 0018 PIN_FLD_FIRST_NAME  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0015 0105   * Jump if condition 'FIRST NAME' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1007 0105   * Store Retainer value for 'first name'. *
COPY 0105 1007   * Get contents of retainer 'first name' <<105E>> *
STOR 0106 0001    *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
COPY 0106 1008   * Get contents of retainer 'last name' <<106E>> *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
COPY 0106 0105   * Copy default string to result register <<106E 105X>> *
COPY 0105 0106   * Concatenate the references <<105E 106X>> *
COPY 0106 0105   * Copy default string to result register <<106E 105X>> *
COPY 0105 0106   * Save the result of the formatting <<105E 106X>> *
COPY 14011 0105   * Copy to transfer register value of Symbolic Link Address <<105X>> *
OUTF 0999 0023 =SCPP  006.000  009.300   * Use absX Use absY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
JUMP 0068  * Jump to end of the case statement *
STOR 0105 0015 PIN_FLD_ADDRESS  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0013 0105   * Jump if condition 'ADDRESS' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1009 0105   * Store Retainer value for 'Address'. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 0106 0105   * Copy default string to result register <<106E 105X>> *
COPY 0105 0106   * Save the result of the formatting <<105E 106X>> *
COPY 14011 0105   * Copy to transfer register value of Symbolic Link Address <<105X>> *
STON 0105 000.000   * Use RelY minus Direction Offset <<105E>> *
ICOP 0109 19828   * Copy indirectly the value of the last Y offset <<109E>> *
ADD  0109 0109 19826   * Add direction offset <<109E>> *
ADD  0108 0105 0109   * Add it to current Y offset <<108E 105X 109X>> *
OUTF 0999 0032 =SCPP  006.000  %Rg007.30108////   * Use absX ( no rel ) Use relY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
JUMP 0052  * Jump to end of the case statement *
STOR 0105 0012 PIN_FLD_CITY  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0003 0105   * Jump if condition 'CITY, STATE, ZIP' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1010 0105   * Store Retainer value for 'CITY'. *
JUMP 0046  * Jump to end of the case statement *
STOR 0105 0013 PIN_FLD_STATE  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0003 0105   * Jump if condition 'STATE' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1011 0105   * Store Retainer value for 'STATE'. *
JUMP 0040  * Jump to end of the case statement *
STOR 0105 0011 PIN_FLD_ZIP  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0023 0105   * Jump if condition 'ZIP' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1012 0105   * Store Retainer value for 'ZIP'. *
COPY 0105 1010   * Get contents of retainer 'CITY' <<105E>> *
STOR 0106 0001    *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
COPY 0106 1011   * Get contents of retainer 'STATE' <<106E>> *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
STOR 0106 0001    *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
COPY 0106 1012   * Get contents of retainer 'ZIP' <<106E>> *
ADD  0105 0105 0106   * Concatenate the two strings. <<105E 106X>> *
COPY 0106 0105   * Copy default string to result register <<106E 105X>> *
COPY 0105 0106   * Concatenate the references <<105E 106X>> *
COPY 0106 0105   * Copy default string to result register <<106E 105X>> *
COPY 0105 0106   * Save the result of the formatting <<105E 106X>> *
COPY 14011 0105   * Copy to transfer register value of Symbolic Link Address <<105X>> *
STON 0105 000.000   * Use RelY minus Direction Offset <<105E>> *
ICOP 0109 19828   * Copy indirectly the value of the last Y offset <<109E>> *
ADD  0109 0109 19826   * Add direction offset <<109E>> *
ADD  0108 0105 0109   * Add it to current Y offset <<108E 105X 109X>> *
OUTF 0999 0032 =SCPP  006.000  %Rg007.30108////   * Use absX ( no rel ) Use relY  *
CLSD 1002 008   * Call appropriate member of the firm data library *
JUMP 0014  * Jump to end of the case statement *
STOR 0105 0017 PIN_FLD_LAST_NAME  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0003 0105   * Jump if condition 'LAST NAME' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1008 0105   * Store Retainer value for 'last name'. *
JUMP 0008  * Jump to end of the case statement *
STOR 0105 0018 PIN_FLD_ACCOUNT_NO  *
EQ   0105 0105 0104   * <<105E 104X>> *
JZ   0003 0105   * Jump if condition 'account number' is not true. *
COPY 0105 15001   * Copy field into work register <<105E>> *
COPY 1013 0105   * Store Retainer value for 'account number a'. *
JUMP 0002  * Jump to end of the case statement *
STON 0104 0001   * <<104E>> *
JUMP 0000  * Final NOP for case statement *
SKIP 1005 0001   * Check to see if the iteration has been started. *
JUMP 0004  * If iteration not started, do not terminate it. *
OUTF 0999 0011 =ECBB 01004   * End calc of print region of iteration size (eg a single 'it') *
STON 1004 0000   * Clear flag :  calc box has already started *
SKIP 0041 0001   * Skip saving the height ( but use default ) if no objects *
JUMP 0002  * Jump since it is zero *
COPY 1006 0039   * Save the current Y offset *
STON 19828 1006   * Set Y offset reg to last used *
STON 0104 014   * Since iterating 'while tag is same', set up proper condition with our tag id *
NEQ  0106 0104 0045   * against the tag of the next input record *
SKIP 0106 0001   * Skip if we are at end of current it. *
RETN  * Not the end of iter, so return. *
STON 0104 014   * Store the id of the iteration tag <<104E>> *
NEQ  0105 0104 0045   * Compare id of tag of next input record is this iteration tag <<105E 104X>> *
SKIP 0105 0001   * Skip if this is the last iteration *
RETN  * Return if this is not the last iteration *
STON 1005 0000   * Reset marker so next time iteration is encountered, we know it is the 'first' time. *
COPY 19829 0102   * After ite restore offset X reg value *
COPY 19827 0103   * After ite restore X direction offset  *
STON 19828 0000   * Reset last Y offset register since relativity has ended *
JUMP 0000  * Acts as a ENDIF to the end of iteration code *
INCR 19816  *  Increment the total not of records. *
*
*****
* Now to output rules for repeated fields if any
* exist. These will be called during the execution
* of a page layout and must process tagbins
* depending on this page layout
*****
*

* End of C:\DOC1WS\RESOURCE\NTT\PORTAL11.EAR 16:23 09-Aug-98 ( TOE 3.0p323 )
~8388061
